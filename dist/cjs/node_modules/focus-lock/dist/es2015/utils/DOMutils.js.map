{"version":3,"file":"DOMutils.js","sources":["../../../../../../../node_modules/focus-lock/dist/es2015/utils/DOMutils.js"],"sourcesContent":["import { toArray } from './array';\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\nimport { orderByTabIndex } from './tabOrder';\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\n/**\n * given list of focusable elements keeps the ones user can interact with\n * @param nodes\n * @param visibilityCache\n */\nexport var filterFocusable = function (nodes, visibilityCache) {\n    return toArray(nodes)\n        .filter(function (node) { return isVisibleCached(visibilityCache, node); })\n        .filter(function (node) { return notHiddenInput(node); });\n};\nexport var filterAutoFocusable = function (nodes, cache) {\n    if (cache === void 0) { cache = new Map(); }\n    return toArray(nodes).filter(function (node) { return isAutoFocusAllowedCached(cache, node); });\n};\n/**\n * only tabbable ones\n * (but with guards which would be ignored)\n */\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\n};\n/**\n * actually anything \"focusable\", not only tabbable\n * (without guards, as long as they are not expected to be focused)\n */\nexport var getAllTabbableNodes = function (topNodes, visibilityCache) {\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\n};\n/**\n * return list of nodes which are expected to be auto-focused\n * @param topNode\n * @param visibilityCache\n */\nexport var parentAutofocusables = function (topNode, visibilityCache) {\n    return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\n};\n/*\n * Determines if element is contained in scope, including nested shadow DOMs\n */\nexport var contains = function (scope, element) {\n    return ((scope.shadowRoot\n        ? contains(scope.shadowRoot, element)\n        : Object.getPrototypeOf(scope).contains.call(scope, element)) ||\n        toArray(scope.children).some(function (child) { return contains(child, element); }));\n};\n"],"names":["filterFocusable","nodes","visibilityCache","toArray","filter","node","isVisibleCached","notHiddenInput","contains","scope","element","shadowRoot","Object","getPrototypeOf","call","children","some","child","cache","Map","isAutoFocusAllowedCached","topNodes","orderByTabIndex","getFocusables","withGuards","topNode","getParentAutofocusables"],"mappings":"2KASWA,EAAkB,SAAUC,EAAOC,GAC1C,OAAOC,EAAAA,QAAQF,GACVG,QAAO,SAAUC,GAAQ,OAAOC,EAAeA,gBAACJ,EAAiBG,MACjED,QAAO,SAAUC,GAAQ,OAAOE,EAAcA,eAACF,EAAM,GAC9D,EA8BWG,EAAW,SAAUC,EAAOC,GACnC,OAASD,EAAME,WACTH,EAASC,EAAME,WAAYD,GAC3BE,OAAOC,eAAeJ,GAAOD,SAASM,KAAKL,EAAOC,KACpDP,EAAAA,QAAQM,EAAMM,UAAUC,MAAK,SAAUC,GAAS,OAAOT,EAASS,EAAOP,EAAW,GAC1F,iDAlCiC,SAAUT,EAAOiB,GAE9C,YADc,IAAVA,IAAoBA,EAAQ,IAAIC,KAC7BhB,UAAQF,GAAOG,QAAO,SAAUC,GAAQ,OAAOe,EAAAA,yBAAyBF,EAAOb,EAAQ,GAClG,wDAYiC,SAAUgB,EAAUnB,GACjD,OAAOoB,EAAAA,gBAAgBtB,EAAgBuB,EAAaA,cAACF,GAAWnB,IAAkB,EACtF,2BAT8B,SAAUmB,EAAUnB,EAAiBsB,GAC/D,OAAOF,EAAeA,gBAACtB,EAAgBuB,EAAAA,cAAcF,EAAUG,GAAatB,IAAkB,EAAMsB,EACxG,+BAakC,SAAUC,EAASvB,GACjD,OAAOF,EAAgB0B,EAAuBA,wBAACD,GAAUvB,EAC7D"}