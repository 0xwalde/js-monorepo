{"version":3,"file":"chakra-ui-hooks.esm.js","sources":["../../../../../../node_modules/@chakra-ui/hooks/dist/chakra-ui-hooks.esm.js"],"sourcesContent":["import * as React from 'react';\nimport React__default, { useState, useMemo, useCallback, useEffect, useRef } from 'react';\nimport { u as useCallbackRef, a as useSafeLayoutEffect, b as useEventListener } from './use-animation-state-5054a9f7.esm.js';\nexport { c as useAnimationState, u as useCallbackRef, b as useEventListener, a as useSafeLayoutEffect } from './use-animation-state-5054a9f7.esm.js';\nimport copy from 'copy-to-clipboard';\nimport { runIfFn, getBox, callAllHandlers, wrapPointerEventHandler, getPointerEventName, hasFocusWithin, focus, getActiveElement, contains, isTabbable, detectBrowser, isRefObject, isActiveElement, getOwnerDocument, getAllFocusable, noop, PanSession } from '@chakra-ui/utils';\n\n/**\n * React hook to manage boolean (on - off) states\n *\n * @param initialState the initial boolean state value\n */\nfunction useBoolean(initialState) {\n  if (initialState === void 0) {\n    initialState = false;\n  }\n\n  var _useState = useState(initialState),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  var callbacks = useMemo(function () {\n    return {\n      on: function on() {\n        return setValue(true);\n      },\n      off: function off() {\n        return setValue(false);\n      },\n      toggle: function toggle() {\n        return setValue(function (prev) {\n          return !prev;\n        });\n      }\n    };\n  }, []);\n  return [value, callbacks];\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"timeout\"];\n\n/**\n * React hook to copy content to clipboard\n *\n * @param text the text or value to copy\n * @param {Number} [optionsOrTimeout=1500] optionsOrTimeout - delay (in ms) to switch back to initial state once copied.\n * @param {Object} optionsOrTimeout\n * @param {string} optionsOrTimeout.format - set the desired MIME type\n * @param {number} optionsOrTimeout.timeout - delay (in ms) to switch back to initial state once copied.\n */\nfunction useClipboard(text, optionsOrTimeout) {\n  if (optionsOrTimeout === void 0) {\n    optionsOrTimeout = {};\n  }\n\n  var _useState = useState(false),\n      hasCopied = _useState[0],\n      setHasCopied = _useState[1];\n\n  var _ref = typeof optionsOrTimeout === \"number\" ? {\n    timeout: optionsOrTimeout\n  } : optionsOrTimeout,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? 1500 : _ref$timeout,\n      copyOptions = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var onCopy = useCallback(function () {\n    var didCopy = copy(text, copyOptions);\n    setHasCopied(didCopy);\n  }, [text, copyOptions]);\n  useEffect(function () {\n    var timeoutId = null;\n\n    if (hasCopied) {\n      timeoutId = window.setTimeout(function () {\n        setHasCopied(false);\n      }, timeout);\n    }\n\n    return function () {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n      }\n    };\n  }, [timeout, hasCopied]);\n  return {\n    value: text,\n    onCopy: onCopy,\n    hasCopied: hasCopied\n  };\n}\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConst`\n * you can ensure that initializers don't execute twice or more.\n */\nfunction useConst(init) {\n  // Use useRef to store the value because it's the least expensive built-in\n  // hook that works here. We could also use `useState` but that's more\n  // expensive internally due to reducer handling which we don't need.\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = typeof init === \"function\" ? init() : init;\n  }\n\n  return ref.current;\n}\n\nfunction useControllableProp(prop, state) {\n  var isControlled = prop !== undefined;\n  var value = isControlled && typeof prop !== \"undefined\" ? prop : state;\n  return [isControlled, value];\n}\n\n/**\n * React hook for using controlling component state.\n * @param props\n */\nfunction useControllableState(props) {\n  var valueProp = props.value,\n      defaultValue = props.defaultValue,\n      onChange = props.onChange,\n      _props$shouldUpdate = props.shouldUpdate,\n      shouldUpdate = _props$shouldUpdate === void 0 ? function (prev, next) {\n    return prev !== next;\n  } : _props$shouldUpdate;\n  var onChangeProp = useCallbackRef(onChange);\n  var shouldUpdateProp = useCallbackRef(shouldUpdate);\n\n  var _React$useState = React.useState(defaultValue),\n      valueState = _React$useState[0],\n      setValue = _React$useState[1];\n\n  var isControlled = valueProp !== undefined;\n  var value = isControlled ? valueProp : valueState;\n  var updateValue = React.useCallback(function (next) {\n    var nextValue = runIfFn(next, value);\n\n    if (!shouldUpdateProp(value, nextValue)) {\n      return;\n    }\n\n    if (!isControlled) {\n      setValue(nextValue);\n    }\n\n    onChangeProp(nextValue);\n  }, [isControlled, onChangeProp, value, shouldUpdateProp]);\n  return [value, updateValue];\n}\n\n/**\n * React hook to measure a component's dimensions\n *\n * @param ref ref of the component to measure\n * @param observe if `true`, resize and scroll observers will be turned on\n */\n\nfunction useDimensions(ref, observe) {\n  var _React$useState = React.useState(null),\n      dimensions = _React$useState[0],\n      setDimensions = _React$useState[1];\n\n  var rafId = React.useRef();\n  useSafeLayoutEffect(function () {\n    if (!ref.current) return undefined;\n    var node = ref.current;\n\n    function measure() {\n      rafId.current = requestAnimationFrame(function () {\n        var boxModel = getBox(node);\n        setDimensions(boxModel);\n      });\n    }\n\n    measure();\n\n    if (observe) {\n      window.addEventListener(\"resize\", measure);\n      window.addEventListener(\"scroll\", measure);\n    }\n\n    return function () {\n      if (observe) {\n        window.removeEventListener(\"resize\", measure);\n        window.removeEventListener(\"scroll\", measure);\n      }\n\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n    };\n  }, [observe]);\n  return dimensions;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// This implementation is heavily inspired by react-aria's implementation\nfunction useId(idProp, prefix) {\n  var id = React.useId();\n  return React.useMemo(function () {\n    return idProp || [prefix, id].filter(Boolean).join(\"-\");\n  }, [idProp, prefix, id]);\n}\n/**\n * React hook to generate ids for use in compound components\n *\n * @param idProp the external id passed from the user\n * @param prefixes array of prefixes to use\n *\n * @example\n *\n * ```js\n * const [buttonId, menuId] = useIds(\"52\", \"button\", \"menu\")\n *\n * // buttonId will be `button-52`\n * // menuId will be `menu-52`\n * ```\n */\n\nfunction useIds(idProp) {\n  for (var _len = arguments.length, prefixes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    prefixes[_key - 1] = arguments[_key];\n  }\n\n  var id = useId(idProp);\n  return React.useMemo(function () {\n    return prefixes.map(function (prefix) {\n      return prefix + \"-\" + id;\n    });\n  }, [id, prefixes]);\n}\n/**\n * Used to generate an id, and after render, check if that id is rendered, so we know\n * if we can use it in places such as `aria-labelledby`.\n *\n * @param partId - The unique id for the component part\n *\n * @example\n * const { ref, id } = useOptionalPart<HTMLInputElement>(`${id}-label`)\n */\n\nfunction useOptionalPart(partId) {\n  var _React$useState = React.useState(null),\n      id = _React$useState[0],\n      setId = _React$useState[1];\n\n  var ref = React.useCallback(function (node) {\n    setId(node ? partId : null);\n  }, [partId]);\n  return {\n    ref: ref,\n    id: id,\n    isRendered: Boolean(id)\n  };\n}\n\nfunction useDisclosure(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      onCloseProp = _props.onClose,\n      onOpenProp = _props.onOpen,\n      isOpenProp = _props.isOpen,\n      idProp = _props.id;\n  var onOpenPropCallbackRef = useCallbackRef(onOpenProp);\n  var onClosePropCallbackRef = useCallbackRef(onCloseProp);\n\n  var _React$useState = React.useState(props.defaultIsOpen || false),\n      isOpenState = _React$useState[0],\n      setIsOpen = _React$useState[1];\n\n  var _useControllableProp = useControllableProp(isOpenProp, isOpenState),\n      isControlled = _useControllableProp[0],\n      isOpen = _useControllableProp[1];\n\n  var id = useId(idProp, \"disclosure\");\n  var onClose = React.useCallback(function () {\n    if (!isControlled) {\n      setIsOpen(false);\n    }\n\n    onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();\n  }, [isControlled, onClosePropCallbackRef]);\n  var onOpen = React.useCallback(function () {\n    if (!isControlled) {\n      setIsOpen(true);\n    }\n\n    onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();\n  }, [isControlled, onOpenPropCallbackRef]);\n  var onToggle = React.useCallback(function () {\n    var action = isOpen ? onClose : onOpen;\n    action();\n  }, [isOpen, onOpen, onClose]);\n  return {\n    isOpen: !!isOpen,\n    onOpen: onOpen,\n    onClose: onClose,\n    onToggle: onToggle,\n    isControlled: isControlled,\n    getButtonProps: function getButtonProps(props) {\n      if (props === void 0) {\n        props = {};\n      }\n\n      return _extends({}, props, {\n        \"aria-expanded\": isOpen,\n        \"aria-controls\": id,\n        onClick: callAllHandlers(props.onClick, onToggle)\n      });\n    },\n    getDisclosureProps: function getDisclosureProps(props) {\n      if (props === void 0) {\n        props = {};\n      }\n\n      return _extends({}, props, {\n        hidden: !isOpen,\n        id: id\n      });\n    }\n  };\n}\n\nfunction useEventListenerMap() {\n  var listeners = React.useRef(new Map());\n  var currentListeners = listeners.current;\n  var add = React.useCallback(function (el, type, listener, options) {\n    var pointerEventListener = wrapPointerEventHandler(listener, type === \"pointerdown\");\n    listeners.current.set(listener, {\n      __listener: pointerEventListener,\n      type: getPointerEventName(type),\n      el: el,\n      options: options\n    });\n    el.addEventListener(type, pointerEventListener, options);\n  }, []);\n  var remove = React.useCallback(function (el, type, listener, options) {\n    var _listeners$current$ge = listeners.current.get(listener),\n        pointerEventListener = _listeners$current$ge.__listener;\n\n    el.removeEventListener(type, pointerEventListener, options);\n    listeners.current[\"delete\"](pointerEventListener);\n  }, []);\n  React.useEffect(function () {\n    return function () {\n      currentListeners.forEach(function (value, key) {\n        remove(value.el, value.type, key, value.options);\n      });\n    };\n  }, [remove, currentListeners]);\n  return {\n    add: add,\n    remove: remove\n  };\n}\n\n/**\n * React effect hook that invokes only on update.\n * It doesn't invoke on mount\n */\n\nvar useUpdateEffect = function useUpdateEffect(effect, deps) {\n  var renderCycleRef = React.useRef(false);\n  var effectCycleRef = React.useRef(false);\n  React.useEffect(function () {\n    var isMounted = renderCycleRef.current;\n    var shouldRun = isMounted && effectCycleRef.current;\n\n    if (shouldRun) {\n      return effect();\n    }\n\n    effectCycleRef.current = true; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n  React.useEffect(function () {\n    renderCycleRef.current = true;\n    return function () {\n      renderCycleRef.current = false;\n    };\n  }, []);\n};\n\n/**\n * React hook to focus an element conditionally\n *\n * @param ref the ref of the element to focus\n * @param options focus management options\n */\nfunction useFocusEffect(ref, options) {\n  var shouldFocus = options.shouldFocus,\n      preventScroll = options.preventScroll;\n  useUpdateEffect(function () {\n    var node = ref.current;\n    if (!node || !shouldFocus) return;\n\n    if (!hasFocusWithin(node)) {\n      focus(node, {\n        preventScroll: preventScroll,\n        nextTick: true\n      });\n    }\n  }, [shouldFocus, ref, preventScroll]);\n}\n\nfunction preventReturnFocus(containerRef) {\n  var el = containerRef.current;\n  if (!el) return false;\n  var activeElement = getActiveElement(el);\n  if (!activeElement) return false;\n  if (contains(el, activeElement)) return false;\n  if (isTabbable(activeElement)) return true;\n  return false;\n}\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\n\n\nfunction useFocusOnHide(containerRef, options) {\n  var shouldFocusProp = options.shouldFocus,\n      visible = options.visible,\n      focusRef = options.focusRef;\n  var shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(function () {\n    if (!shouldFocus) return;\n\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n\n    var el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n\n    if (el) {\n      focus(el, {\n        nextTick: true\n      });\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\n\n/**\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n/**\n * @internal\n */\n\nfunction usePointerEvent(env, eventName, handler, options) {\n  return useEventListener(getPointerEventName(eventName), wrapPointerEventHandler(handler, eventName === \"pointerdown\"), env, options);\n}\n\n/**\n * Polyfill to get `relatedTarget` working correctly consistently\n * across all browsers.\n *\n * It ensures that elements receives focus on pointer down if\n * it's not the active element.\n *\n * @internal\n */\nfunction useFocusOnPointerDown(props) {\n  var ref = props.ref,\n      elements = props.elements,\n      enabled = props.enabled;\n  var isSafari = detectBrowser(\"Safari\");\n\n  var doc = function doc() {\n    return getOwnerDocument(ref.current);\n  };\n\n  usePointerEvent(doc, \"pointerdown\", function (event) {\n    if (!isSafari || !enabled) return;\n    var target = event.target;\n    var els = elements != null ? elements : [ref];\n    var isValidTarget = els.some(function (elementOrRef) {\n      var el = isRefObject(elementOrRef) ? elementOrRef.current : elementOrRef;\n      return contains(el, target);\n    });\n\n    if (!isActiveElement(target) && isValidTarget) {\n      event.preventDefault();\n      focus(target);\n    }\n  });\n}\n\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\nfunction useFocusOnShow(target, options) {\n  if (options === void 0) {\n    options = defaultOptions;\n  }\n\n  var _options = options,\n      focusRef = _options.focusRef,\n      preventScroll = _options.preventScroll,\n      shouldFocus = _options.shouldFocus,\n      visible = _options.visible;\n  var element = isRefObject(target) ? target.current : target;\n  var autoFocus = shouldFocus && visible;\n  var onFocus = useCallback(function () {\n    if (!element || !autoFocus) return;\n    if (contains(element, document.activeElement)) return;\n\n    if (focusRef != null && focusRef.current) {\n      focus(focusRef.current, {\n        preventScroll: preventScroll,\n        nextTick: true\n      });\n    } else {\n      var tabbableEls = getAllFocusable(element);\n\n      if (tabbableEls.length > 0) {\n        focus(tabbableEls[0], {\n          preventScroll: preventScroll,\n          nextTick: true\n        });\n      }\n    }\n  }, [autoFocus, preventScroll, element, focusRef]);\n  useUpdateEffect(function () {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(\"transitionend\", onFocus, element);\n}\n\nfunction useUnmountEffect(fn, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n\n  return React.useEffect(function () {\n    return function () {\n      return fn();\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n}\n\nfunction useForceUpdate() {\n  var unloadingRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      count = _React$useState[0],\n      setCount = _React$useState[1];\n\n  useUnmountEffect(function () {\n    unloadingRef.current = true;\n  });\n  return React.useCallback(function () {\n    if (!unloadingRef.current) {\n      setCount(count + 1);\n    }\n  }, [count]);\n}\n\n/**\n * React Hook that provides a declarative `setInterval`\n *\n * @param callback the callback to execute at interval\n * @param delay the `setInterval` delay (in ms)\n */\n\nfunction useInterval(callback, delay) {\n  var fn = useCallbackRef(callback);\n  React.useEffect(function () {\n    var intervalId = null;\n\n    var tick = function tick() {\n      return fn();\n    };\n\n    if (delay !== null) {\n      intervalId = window.setInterval(tick, delay);\n    }\n\n    return function () {\n      if (intervalId) {\n        window.clearInterval(intervalId);\n      }\n    };\n  }, [delay, fn]);\n}\n\n/**\n * React hook to persist any value between renders,\n * but keeps it up-to-date if it changes.\n *\n * @param value the value or function to persist\n */\n\nfunction useLatestRef(value) {\n  var ref = React.useRef(null);\n  ref.current = value;\n  return ref;\n}\n\n/* eslint-disable react-hooks/exhaustive-deps */\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (typeof ref === \"function\") {\n    ref(value);\n    return;\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value;\n  } catch (error) {\n    throw new Error(\"Cannot assign value '\" + value + \"' to ref '\" + ref + \"'\");\n  }\n}\n/**\n * React hook that merges react refs into a single memoized function\n *\n * @example\n * import React from \"react\";\n * import { useMergeRefs } from `@chakra-ui/hooks`;\n *\n * const Component = React.forwardRef((props, ref) => {\n *   const internalRef = React.useRef();\n *   return <div {...props} ref={useMergeRefs(internalRef, ref)} />;\n * });\n */\n\nfunction useMergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return React.useMemo(function () {\n    if (refs.every(function (ref) {\n      return ref == null;\n    })) {\n      return null;\n    }\n\n    return function (node) {\n      refs.forEach(function (ref) {\n        if (ref) assignRef(ref, node);\n      });\n    };\n  }, refs);\n}\n\nfunction useMouseDownRef(shouldListen) {\n  if (shouldListen === void 0) {\n    shouldListen = true;\n  }\n\n  var mouseDownRef = React__default.useRef();\n  useEventListener(\"mousedown\", function (event) {\n    if (shouldListen) {\n      mouseDownRef.current = event.target;\n    }\n  });\n  return mouseDownRef;\n}\n\n/**\n * Example, used in components like Dialogs and Popovers, so they can close\n * when a user clicks outside them.\n */\nfunction useOutsideClick(props) {\n  var ref = props.ref,\n      handler = props.handler,\n      _props$enabled = props.enabled,\n      enabled = _props$enabled === void 0 ? true : _props$enabled;\n  var savedHandler = useCallbackRef(handler);\n  var stateRef = useRef({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n  var state = stateRef.current;\n  useEffect(function () {\n    if (!enabled) return;\n\n    var onPointerDown = function onPointerDown(e) {\n      if (isValidEvent(e, ref)) {\n        state.isPointerDown = true;\n      }\n    };\n\n    var onMouseUp = function onMouseUp(event) {\n      if (state.ignoreEmulatedMouseEvents) {\n        state.ignoreEmulatedMouseEvents = false;\n        return;\n      }\n\n      if (state.isPointerDown && handler && isValidEvent(event, ref)) {\n        state.isPointerDown = false;\n        savedHandler(event);\n      }\n    };\n\n    var onTouchEnd = function onTouchEnd(event) {\n      state.ignoreEmulatedMouseEvents = true;\n\n      if (handler && state.isPointerDown && isValidEvent(event, ref)) {\n        state.isPointerDown = false;\n        savedHandler(event);\n      }\n    };\n\n    var doc = getOwnerDocument(ref.current);\n    doc.addEventListener(\"mousedown\", onPointerDown, true);\n    doc.addEventListener(\"mouseup\", onMouseUp, true);\n    doc.addEventListener(\"touchstart\", onPointerDown, true);\n    doc.addEventListener(\"touchend\", onTouchEnd, true);\n    return function () {\n      doc.removeEventListener(\"mousedown\", onPointerDown, true);\n      doc.removeEventListener(\"mouseup\", onMouseUp, true);\n      doc.removeEventListener(\"touchstart\", onPointerDown, true);\n      doc.removeEventListener(\"touchend\", onTouchEnd, true);\n    };\n  }, [handler, ref, savedHandler, state, enabled]);\n}\n\nfunction isValidEvent(event, ref) {\n  var _ref$current;\n\n  var target = event.target;\n  if (event.button > 0) return false; // if the event target is no longer in the document\n\n  if (target) {\n    var doc = getOwnerDocument(target);\n    if (!doc.contains(target)) return false;\n  }\n\n  return !((_ref$current = ref.current) != null && _ref$current.contains(target));\n}\n\nfunction usePanGesture(ref, props) {\n  var onPan = props.onPan,\n      onPanStart = props.onPanStart,\n      onPanEnd = props.onPanEnd,\n      onPanSessionStart = props.onPanSessionStart,\n      onPanSessionEnd = props.onPanSessionEnd,\n      threshold = props.threshold;\n  var hasPanEvents = Boolean(onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd);\n  var panSession = useRef(null);\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onSessionEnd: onPanSessionEnd,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function onEnd(event, info) {\n      panSession.current = null;\n      onPanEnd == null ? void 0 : onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    var _panSession$current;\n\n    (_panSession$current = panSession.current) == null ? void 0 : _panSession$current.updateHandlers(handlers);\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, threshold);\n  }\n\n  usePointerEvent(function () {\n    return ref.current;\n  }, \"pointerdown\", hasPanEvents ? onPointerDown : noop);\n  useUnmountEffect(function () {\n    var _panSession$current2;\n\n    (_panSession$current2 = panSession.current) == null ? void 0 : _panSession$current2.end();\n    panSession.current = null;\n  });\n}\n\nfunction usePrevious(value) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\n/**\n * Checks if the key pressed is a printable character\n * and can be used for shortcut navigation\n */\n\nfunction isPrintableCharacter(event) {\n  var key = event.key;\n  return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);\n}\n\n/**\n * React hook that provides an enhanced keydown handler,\n * that's used for key navigation within menus, select dropdowns.\n */\nfunction useShortcut(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      _props$timeout = _props.timeout,\n      timeout = _props$timeout === void 0 ? 300 : _props$timeout,\n      _props$preventDefault = _props.preventDefault,\n      preventDefault = _props$preventDefault === void 0 ? function () {\n    return true;\n  } : _props$preventDefault;\n\n  var _React$useState = React.useState([]),\n      keys = _React$useState[0],\n      setKeys = _React$useState[1];\n\n  var timeoutRef = React.useRef();\n\n  var flush = function flush() {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  };\n\n  var clearKeysAfterDelay = function clearKeysAfterDelay() {\n    flush();\n    timeoutRef.current = setTimeout(function () {\n      setKeys([]);\n      timeoutRef.current = null;\n    }, timeout);\n  };\n\n  React.useEffect(function () {\n    return flush;\n  }, []);\n\n  function onKeyDown(fn) {\n    return function (event) {\n      if (event.key === \"Backspace\") {\n        var keysCopy = [].concat(keys);\n        keysCopy.pop();\n        setKeys(keysCopy);\n        return;\n      }\n\n      if (isPrintableCharacter(event)) {\n        var _keysCopy = keys.concat(event.key);\n\n        if (preventDefault(event)) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n\n        setKeys(_keysCopy);\n        fn(_keysCopy.join(\"\"));\n        clearKeysAfterDelay();\n      }\n    };\n  }\n\n  return onKeyDown;\n}\n\n/**\n * React hook that provides a declarative `setTimeout`\n *\n * @param callback the callback to run after specified delay\n * @param delay the delay (in ms)\n */\n\nfunction useTimeout(callback, delay) {\n  var fn = useCallbackRef(callback);\n  React.useEffect(function () {\n    if (delay == null) return undefined;\n    var timeoutId = null;\n    timeoutId = window.setTimeout(function () {\n      fn();\n    }, delay);\n    return function () {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n      }\n    };\n  }, [delay, fn]);\n}\n\nfunction useWhyDidYouUpdate(name, props) {\n  var previousProps = React.useRef();\n  React.useEffect(function () {\n    if (previousProps.current) {\n      var allKeys = Object.keys(_extends({}, previousProps.current, props));\n      var changesObj = {};\n      allKeys.forEach(function (key) {\n        if (previousProps.current[key] !== props[key]) {\n          changesObj[key] = {\n            from: previousProps.current[key],\n            to: props[key]\n          };\n        }\n      });\n\n      if (Object.keys(changesObj).length) {\n        console.log(\"[why-did-you-update]\", name, changesObj);\n      }\n    }\n\n    previousProps.current = props;\n  });\n}\n\nexport { assignRef, useBoolean, useClipboard, useConst, useControllableProp, useControllableState, useDimensions, useDisclosure, useEventListenerMap, useFocusEffect, useFocusOnHide, useFocusOnPointerDown, useFocusOnShow, useForceUpdate, useId, useIds, useInterval, useLatestRef, useMergeRefs, useMouseDownRef, useOptionalPart, useOutsideClick, usePanGesture, usePointerEvent, usePrevious, useShortcut, useTimeout, useUnmountEffect, useUpdateEffect, useWhyDidYouUpdate };\n"],"names":["useControllableProp","prop","state","isControlled","undefined","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","useId","idProp","prefix","id","React.useId","React.useMemo","react","exports","useMemo","filter","Boolean","join","usePointerEvent","env","eventName","handler","options","useEventListener","getPointerEventName","wrapPointerEventHandler","useUnmountEffect","fn","deps","React.useEffect","useEffect","assignRef","ref","value","current","error","Error","initialState","_useState","useState","setValue","on","off","toggle","prev","props","valueProp","defaultValue","onChange","_props$shouldUpdate","shouldUpdate","next","onChangeProp","useCallbackRef","shouldUpdateProp","_React$useState","React.useState","valueState","updateValue","React.useCallback","nextValue","runIfFn","observe","dimensions","setDimensions","rafId","React.useRef","useSafeLayoutEffect","node","measure","window","addEventListener","removeEventListener","cancelAnimationFrame","requestAnimationFrame","boxModel","getBox","_props","onCloseProp","onClose","onOpenProp","onOpen","isOpenProp","isOpen","onOpenPropCallbackRef","onClosePropCallbackRef","defaultIsOpen","isOpenState","setIsOpen","_useControllableProp","onToggle","getButtonProps","onClick","callAllHandlers","getDisclosureProps","hidden","elements","enabled","isSafari","detectBrowser","getOwnerDocument","event","isValidTarget","some","elementOrRef","el","isRefObject","contains","isActiveElement","preventDefault","focus","unloadingRef","count","setCount","useCallback","_len","prefixes","Array","_key","map","callback","delay","intervalId","setInterval","clearInterval","refs","every","forEach","onPan","onPanStart","onPanEnd","onPanSessionStart","onPanSessionEnd","threshold","hasPanEvents","panSession","useRef","handlers","onSessionStart","onSessionEnd","onStart","onMove","onEnd","info","_panSession$current","updateHandlers","PanSession","noop","_panSession$current2","end","_props$timeout","timeout","_props$preventDefault","keys","setKeys","timeoutRef","flush","clearTimeout","keysCopy","concat","pop","test","isPrintableCharacter","_keysCopy","stopPropagation","setTimeout","timeoutId","effect","renderCycleRef","effectCycleRef"],"mappings":"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"}