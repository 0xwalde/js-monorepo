{"version":3,"file":"preventOverflow.js","sources":["../../../../../../../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"],"sourcesContent":["import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};"],"names":["preventOverflow$1","name","enabled","phase","fn","_ref","state","options","_options$mainAxis","mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","boundary","rootBoundary","altBoundary","padding","_options$tether","tether","_options$tetherOffset","tetherOffset","overflow","detectOverflow","basePlacement","getBasePlacement","placement","variation","getVariation","isBasePlacement","getMainAxisFromPlacement","getAltAxis","popperOffsets","modifiersData","referenceRect","rects","reference","popperRect","popper","tetherOffsetValue","Object","assign","normalizedTetherOffsetValue","offsetModifierState","offset","data","x","y","_offsetModifierState$","mainSide","top","left","altSide","bottom","right","len","min","max","additive","minLen","start","maxLen","arrowElement","elements","arrow","arrowRect","getLayoutRect","width","height","arrowPaddingObject","getFreshSideObject","arrowPaddingMin","arrowPaddingMax","arrowLen","within","minOffset","maxOffset","arrowOffsetParent","getOffsetParent","clientOffset","clientTop","clientLeft","offsetModifierValue","tetherMin","tetherMax","preventedOffset","mathMin","mathMax","_offsetModifierState$2","_mainSide","_altSide","_offset","_len","_min","_max","isOriginSide","indexOf","_offsetModifierValue","_tetherMin","_tetherMax","_preventedOffset","withinMaxClamp","requiresIfExists"],"mappings":"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"}