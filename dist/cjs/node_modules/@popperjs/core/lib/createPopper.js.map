{"version":3,"file":"createPopper.js","sources":["../../../../../../node_modules/@popperjs/core/lib/createPopper.js"],"sourcesContent":["import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };"],"names":["INVALID_ELEMENT_ERROR","DEFAULT_OPTIONS","placement","modifiers","strategy","areValidElements","_len","arguments","length","args","Array","_key","some","element","getBoundingClientRect","generatorOptions","_generatorOptions","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","reference","popper","options","state","orderedModifiers","Object","assign","modifiersData","elements","attributes","styles","effectCleanupFns","isDestroyed","instance","setOptions","setOptionsAction","cleanupModifierEffects","scrollParents","isElement","listScrollParents","contextElement","orderModifiers","mergeByName","concat","filter","m","enabled","process","env","NODE_ENV","uniqueBy","_ref","name","validateModifiers","getBasePlacement","auto","find","_ref2","console","error","join","_getComputedStyle","getComputedStyle","marginTop","marginRight","marginBottom","marginLeft","margin","parseFloat","warn","forEach","_ref3","_ref3$options","effect","cleanupFn","noopFn","push","update","forceUpdate","_state$elements","rects","getCompositeRect","getOffsetParent","getLayoutRect","reset","modifier","data","__debug_loops__","index","_state$orderedModifie","fn","_state$orderedModifie2","_options","debounce","Promise","resolve","destroy","then","onFirstUpdate"],"mappings":"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"}