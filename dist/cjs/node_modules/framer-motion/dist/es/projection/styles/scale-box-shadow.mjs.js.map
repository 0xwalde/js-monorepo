{"version":3,"file":"scale-box-shadow.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs"],"sourcesContent":["import { mix } from 'popmotion';\nimport { complex } from 'style-value-types';\nimport { cssVariableRegex } from '../../render/dom/utils/css-variables-conversion.mjs';\n\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n    correct: function (latest, _a) {\n        var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;\n        var original = latest;\n        /**\n         * We need to first strip and store CSS variables from the string.\n         */\n        var containsCSSVariables = latest.includes(\"var(\");\n        var cssVariables = [];\n        if (containsCSSVariables) {\n            latest = latest.replace(cssVariableRegex, function (match) {\n                cssVariables.push(match);\n                return varToken;\n            });\n        }\n        var shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        var template = complex.createTransformer(latest);\n        var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        var xScale = projectionDelta.x.scale * treeScale.x;\n        var yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        var averageScale = mix(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        var output = template(shadow);\n        if (containsCSSVariables) {\n            var i_1 = 0;\n            output = output.replace(varToken, function () {\n                var cssVariable = cssVariables[i_1];\n                i_1++;\n                return cssVariable;\n            });\n        }\n        return output;\n    },\n};\n\nexport { correctBoxShadow };\n"],"names":["correctBoxShadow","correct","latest","_a","treeScale","projectionDelta","original","containsCSSVariables","includes","cssVariables","replace","cssVariableRegex","match","push","shadow","complex","parse","length","template","createTransformer","offset","xScale","x","scale","yScale","y","averageScale","mix","output","i_1","cssVariable"],"mappings":"sRAKIA,EAAmB,CACnBC,QAAS,SAAUC,EAAQC,GACvB,IAAIC,EAAYD,EAAGC,UAAWC,EAAkBF,EAAGE,gBAC/CC,EAAWJ,EAIXK,EAAuBL,EAAOM,SAAS,QACvCC,EAAe,GACfF,IACAL,EAASA,EAAOQ,QAAQC,EAAgBA,kBAAE,SAAUC,GAEhD,OADAH,EAAaI,KAAKD,GAZnB,OAcf,KAEQ,IAAIE,EAASC,EAAAA,QAAQC,MAAMd,GAE3B,GAAIY,EAAOG,OAAS,EAChB,OAAOX,EACX,IAAIY,EAAWH,EAAAA,QAAQI,kBAAkBjB,GACrCkB,EAA8B,iBAAdN,EAAO,GAAkB,EAAI,EAE7CO,EAAShB,EAAgBiB,EAAEC,MAAQnB,EAAUkB,EAC7CE,EAASnB,EAAgBoB,EAAEF,MAAQnB,EAAUqB,EACjDX,EAAO,EAAIM,IAAWC,EACtBP,EAAO,EAAIM,IAAWI,EAOtB,IAAIE,EAAeC,EAAGA,IAACN,EAAQG,EAAQ,IAEL,iBAAvBV,EAAO,EAAIM,KAClBN,EAAO,EAAIM,IAAWM,GAEQ,iBAAvBZ,EAAO,EAAIM,KAClBN,EAAO,EAAIM,IAAWM,GAC1B,IAAIE,EAASV,EAASJ,GACtB,GAAIP,EAAsB,CACtB,IAAIsB,EAAM,EACVD,EAASA,EAAOlB,QA3Cb,SA2C+B,WAC9B,IAAIoB,EAAcrB,EAAaoB,GAE/B,OADAA,IACOC,CACvB,GACS,CACD,OAAOF,CACV"}