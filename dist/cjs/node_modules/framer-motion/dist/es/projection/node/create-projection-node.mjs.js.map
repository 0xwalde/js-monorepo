{"version":3,"file":"create-projection-node.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs"],"sourcesContent":["import { __spreadArray, __read, __assign } from 'tslib';\nimport sync, { cancelSync, flushSync } from 'framesync';\nimport { mix } from 'popmotion';\nimport { animate } from '../../animation/animate.mjs';\nimport { SubscriptionManager } from '../../utils/subscription-manager.mjs';\nimport { mixValues } from '../animation/mix-values.mjs';\nimport { copyBoxInto } from '../geometry/copy.mjs';\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\nimport { calcRelativePosition, calcRelativeBox, calcBoxDelta, calcLength } from '../geometry/delta-calc.mjs';\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\nimport { createBox, createDelta } from '../geometry/models.mjs';\nimport { getValueTransition } from '../../animation/utils/transitions.mjs';\nimport { boxEquals, isDeltaZero } from '../geometry/utils.mjs';\nimport { NodeStack } from '../shared/stack.mjs';\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\nimport { buildProjectionTransform } from '../styles/transform.mjs';\nimport { eachAxis } from '../utils/each-axis.mjs';\nimport { hasTransform, hasScale } from '../utils/has-transform.mjs';\nimport { transformAxes } from '../../render/html/utils/transform.mjs';\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { globalProjectionState } from './state.mjs';\n\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nvar animationTarget = 1000;\nfunction createProjectionNode(_a) {\n    var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, checkIsScrollRoot = _a.checkIsScrollRoot, resetTransform = _a.resetTransform;\n    return /** @class */ (function () {\n        function ProjectionNode(id, latestValues, parent) {\n            var _this = this;\n            if (latestValues === void 0) { latestValues = {}; }\n            if (parent === void 0) { parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent(); }\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to actually\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            // Note: Currently only running on root node\n            this.potentialNodes = new Map();\n            this.checkUpdateFailed = function () {\n                if (_this.isUpdating) {\n                    _this.isUpdating = false;\n                    _this.clearAllSnapshots();\n                }\n            };\n            this.updateProjection = function () {\n                _this.nodes.forEach(resolveTargetDelta);\n                _this.nodes.forEach(calcProjection);\n            };\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.id = id;\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            id && this.root.registerPotentialNode(id, this);\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        ProjectionNode.prototype.addEventListener = function (name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        };\n        ProjectionNode.prototype.notifyListeners = function (name) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));\n        };\n        ProjectionNode.prototype.hasListeners = function (name) {\n            return this.eventHandlers.has(name);\n        };\n        ProjectionNode.prototype.registerPotentialNode = function (id, node) {\n            this.potentialNodes.set(id, node);\n        };\n        /**\n         * Lifecycles\n         */\n        ProjectionNode.prototype.mount = function (instance, isLayoutDirty) {\n            var _this = this;\n            var _a;\n            if (isLayoutDirty === void 0) { isLayoutDirty = false; }\n            if (this.instance)\n                return;\n            this.isSVG =\n                instance instanceof SVGElement && instance.tagName !== \"svg\";\n            this.instance = instance;\n            var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement = _b.visualElement;\n            if (visualElement && !visualElement.getInstance()) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n            this.id && this.root.potentialNodes.delete(this.id);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                var unblockTimeout_1;\n                var resizeUnblockUpdate_1 = function () {\n                    return (_this.root.updateBlockedByResize = false);\n                };\n                attachResizeListener(instance, function () {\n                    _this.root.updateBlockedByResize = true;\n                    clearTimeout(unblockTimeout_1);\n                    unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        _this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", function (_a) {\n                    var _b, _c, _d, _e, _f;\n                    var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged, hasRelativeTargetChanged = _a.hasRelativeTargetChanged, newLayout = _a.layout;\n                    if (_this.isTreeAnimationBlocked()) {\n                        _this.target = undefined;\n                        _this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    var layoutTransition = (_c = (_b = _this.options.transition) !== null && _b !== void 0 ? _b : visualElement.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;\n                    var _g = visualElement.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    var targetChanged = !_this.targetLayout ||\n                        !boxEquals(_this.targetLayout, newLayout) ||\n                        hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (targetChanged || !_this.currentAnimation))) {\n                        if (_this.resumeFrom) {\n                            _this.resumingFrom = _this.resumeFrom;\n                            _this.resumingFrom.resumingFrom = undefined;\n                        }\n                        _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, \"layout\")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });\n                        if (visualElement.shouldReduceMotion) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        _this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged &&\n                            _this.animationProgress === 0) {\n                            _this.finishAnimation();\n                        }\n                        _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));\n                    }\n                    _this.targetLayout = newLayout;\n                });\n            }\n        };\n        ProjectionNode.prototype.unmount = function () {\n            var _a, _b;\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n            (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n            this.instance = undefined;\n            cancelSync.preRender(this.updateProjection);\n        };\n        // only on the root\n        ProjectionNode.prototype.blockUpdate = function () {\n            this.updateManuallyBlocked = true;\n        };\n        ProjectionNode.prototype.unblockUpdate = function () {\n            this.updateManuallyBlocked = false;\n        };\n        ProjectionNode.prototype.isUpdateBlocked = function () {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        };\n        ProjectionNode.prototype.isTreeAnimationBlocked = function () {\n            var _a;\n            return (this.isAnimationBlocked ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) ||\n                false);\n        };\n        // Note: currently only running on root node\n        ProjectionNode.prototype.startUpdate = function () {\n            var _a;\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n        };\n        ProjectionNode.prototype.willUpdate = function (shouldNotifyListeners) {\n            var _a, _b, _c;\n            if (shouldNotifyListeners === void 0) { shouldNotifyListeners = true; }\n            if (this.root.isUpdateBlocked()) {\n                (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n                return;\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                node.shouldResetTransform = true;\n                /**\n                 * TODO: Check we haven't updated the scroll\n                 * since the last didUpdate\n                 */\n                node.updateScroll();\n            }\n            var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;\n            if (layoutId === undefined && !layout)\n                return;\n            var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n            this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        };\n        // Note: Currently only running on root node\n        ProjectionNode.prototype.didUpdate = function () {\n            var updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating)\n                return;\n            this.isUpdating = false;\n            /**\n             * Search for and mount newly-added projection elements.\n             *\n             * TODO: Every time a new component is rendered we could search up the tree for\n             * the closest mounted node and query from there rather than document.\n             */\n            if (this.potentialNodes.size) {\n                this.potentialNodes.forEach(mountNodeEarly);\n                this.potentialNodes.clear();\n            }\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            // Flush any scheduled updates\n            flushSync.update();\n            flushSync.preRender();\n            flushSync.render();\n        };\n        ProjectionNode.prototype.clearAllSnapshots = function () {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        };\n        ProjectionNode.prototype.scheduleUpdateProjection = function () {\n            sync.preRender(this.updateProjection, false, true);\n        };\n        ProjectionNode.prototype.scheduleCheckAfterUnmount = function () {\n            var _this = this;\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            sync.postRender(function () {\n                if (_this.isLayoutDirty) {\n                    _this.root.didUpdate();\n                }\n                else {\n                    _this.root.checkUpdateFailed();\n                }\n            });\n        };\n        /**\n         * Update measurements\n         */\n        ProjectionNode.prototype.updateSnapshot = function () {\n            if (this.snapshot || !this.instance)\n                return;\n            var measured = this.measure();\n            var layout = this.removeTransform(this.removeElementScroll(measured));\n            roundBox(layout);\n            this.snapshot = {\n                measured: measured,\n                layout: layout,\n                latestValues: {},\n            };\n        };\n        ProjectionNode.prototype.updateLayout = function () {\n            var _a;\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (var i = 0; i < this.path.length; i++) {\n                    var node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            var measured = this.measure();\n            roundBox(measured);\n            var prevLayout = this.layout;\n            this.layout = {\n                measured: measured,\n                actual: this.removeElementScroll(measured),\n            };\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.actual);\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);\n        };\n        ProjectionNode.prototype.updateScroll = function () {\n            if (this.options.layoutScroll && this.instance) {\n                this.isScrollRoot = checkIsScrollRoot(this.instance);\n                this.scroll = measureScroll(this.instance);\n            }\n        };\n        ProjectionNode.prototype.resetTransform = function () {\n            var _a;\n            if (!resetTransform)\n                return;\n            var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n            var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        };\n        ProjectionNode.prototype.measure = function () {\n            var visualElement = this.options.visualElement;\n            if (!visualElement)\n                return createBox();\n            var box = visualElement.measureViewportBox();\n            // Remove viewport scroll to give page-relative coordinates\n            var scroll = this.root.scroll;\n            if (scroll) {\n                translateAxis(box.x, scroll.x);\n                translateAxis(box.y, scroll.y);\n            }\n            return box;\n        };\n        ProjectionNode.prototype.removeElementScroll = function (box) {\n            var boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;\n                if (node !== this.root && scroll_1 && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (isScrollRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                        var rootScroll = this.root.scroll;\n                        /**\n                         * Undo the application of page scroll that was originally added\n                         * to the measured bounding box.\n                         */\n                        if (rootScroll) {\n                            translateAxis(boxWithoutScroll.x, -rootScroll.x);\n                            translateAxis(boxWithoutScroll.y, -rootScroll.y);\n                        }\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll_1.x);\n                    translateAxis(boxWithoutScroll.y, scroll_1.y);\n                }\n            }\n            return boxWithoutScroll;\n        };\n        ProjectionNode.prototype.applyTransform = function (box, transformOnly) {\n            if (transformOnly === void 0) { transformOnly = false; }\n            var withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.x,\n                        y: -node.scroll.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        };\n        ProjectionNode.prototype.removeTransform = function (box) {\n            var _a;\n            var boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                var sourceBox = createBox();\n                var nodeBox = node.measure();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        };\n        /**\n         *\n         */\n        ProjectionNode.prototype.setTargetDelta = function (delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n        };\n        ProjectionNode.prototype.setOptions = function (options) {\n            var _a;\n            this.options = __assign(__assign(__assign({}, this.options), options), { crossfade: (_a = options.crossfade) !== null && _a !== void 0 ? _a : true });\n        };\n        ProjectionNode.prototype.clearMeasurements = function () {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        };\n        /**\n         * Frame calculations\n         */\n        ProjectionNode.prototype.resolveTargetDelta = function () {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            // TODO If this is unsuccessful this currently happens every frame\n            if (!this.targetDelta && !this.relativeTarget) {\n                // TODO: This is a semi-repetition of further down this function, make DRY\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && this.relativeParent.layout) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.actual);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.actual);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.actual);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent &&\n                    Boolean(this.relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !this.relativeParent.options.layoutScroll &&\n                    this.relativeParent.target) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n        };\n        ProjectionNode.prototype.getClosestProjectingParent = function () {\n            if (!this.parent || hasTransform(this.parent.latestValues))\n                return undefined;\n            if ((this.parent.relativeTarget || this.parent.targetDelta) &&\n                this.parent.layout) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        };\n        ProjectionNode.prototype.calcProjection = function () {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            var lead = this.getLead();\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.actual);\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n            var target = lead.target;\n            if (!target)\n                return;\n            if (!this.projectionDelta) {\n                this.projectionDelta = createDelta();\n                this.projectionDeltaWithTransform = createDelta();\n            }\n            var prevTreeScaleX = this.treeScale.x;\n            var prevTreeScaleY = this.treeScale.y;\n            var prevProjectionTransform = this.projectionTransform;\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n            if (this.projectionTransform !== prevProjectionTransform ||\n                this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n        };\n        ProjectionNode.prototype.hide = function () {\n            this.isVisible = false;\n            // TODO: Schedule render\n        };\n        ProjectionNode.prototype.show = function () {\n            this.isVisible = true;\n            // TODO: Schedule render\n        };\n        ProjectionNode.prototype.scheduleRender = function (notifyAll) {\n            var _a, _b, _c;\n            if (notifyAll === void 0) { notifyAll = true; }\n            (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n            notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        };\n        ProjectionNode.prototype.setAnimationOrigin = function (delta, hasOnlyRelativeTargetChanged) {\n            var _this = this;\n            var _a;\n            if (hasOnlyRelativeTargetChanged === void 0) { hasOnlyRelativeTargetChanged = false; }\n            var snapshot = this.snapshot;\n            var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n            var mixedValues = __assign({}, this.latestValues);\n            var targetDelta = createDelta();\n            this.relativeTarget = this.relativeTargetOrigin = undefined;\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            var relativeLayout = createBox();\n            var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n            var isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n            var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            this.mixTargetDelta = function (latest) {\n                var _a;\n                var progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                _this.setTargetDelta(targetDelta);\n                if (_this.relativeTarget &&\n                    _this.relativeTargetOrigin &&\n                    _this.layout &&\n                    ((_a = _this.relativeParent) === null || _a === void 0 ? void 0 : _a.layout)) {\n                    calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);\n                    mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress);\n                }\n                if (isSharedLayoutAnimation) {\n                    _this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                _this.root.scheduleUpdateProjection();\n                _this.scheduleRender();\n                _this.animationProgress = progress;\n            };\n            this.mixTargetDelta(0);\n        };\n        ProjectionNode.prototype.startAnimation = function (options) {\n            var _this = this;\n            var _a, _b;\n            this.notifyListeners(\"animationStart\");\n            (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            if (this.resumingFrom) {\n                (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelSync.update(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = sync.update(function () {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                _this.currentAnimation = animate(0, animationTarget, __assign(__assign({}, options), { onUpdate: function (latest) {\n                        var _a;\n                        _this.mixTargetDelta(latest);\n                        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, latest);\n                    }, onComplete: function () {\n                        var _a;\n                        (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options);\n                        _this.completeAnimation();\n                    } }));\n                if (_this.resumingFrom) {\n                    _this.resumingFrom.currentAnimation = _this.currentAnimation;\n                }\n                _this.pendingAnimation = undefined;\n            });\n        };\n        ProjectionNode.prototype.completeAnimation = function () {\n            var _a;\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners(\"animationComplete\");\n        };\n        ProjectionNode.prototype.finishAnimation = function () {\n            var _a;\n            if (this.currentAnimation) {\n                (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        };\n        ProjectionNode.prototype.applyTransformsToTarget = function () {\n            var _a = this.getLead(), targetWithTransforms = _a.targetWithTransforms, target = _a.target, layout = _a.layout, latestValues = _a.latestValues;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its actual layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        };\n        ProjectionNode.prototype.registerSharedNode = function (layoutId, node) {\n            var _a, _b, _c;\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            var stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            node.promote({\n                transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n                preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node),\n            });\n        };\n        ProjectionNode.prototype.isLead = function () {\n            var stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        };\n        ProjectionNode.prototype.getLead = function () {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        };\n        ProjectionNode.prototype.getPrevLead = function () {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        };\n        ProjectionNode.prototype.getStack = function () {\n            var layoutId = this.options.layoutId;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        };\n        ProjectionNode.prototype.promote = function (_a) {\n            var _b = _a === void 0 ? {} : _a, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;\n            var stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition: transition });\n        };\n        ProjectionNode.prototype.relegate = function () {\n            var stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        };\n        ProjectionNode.prototype.resetRotation = function () {\n            var visualElement = this.options.visualElement;\n            if (!visualElement)\n                return;\n            // If there's no detected rotation values, we can early return without a forced render.\n            var hasRotate = false;\n            // Keep a record of all the values we've reset\n            var resetValues = {};\n            // Check the rotate value of all axes and reset to 0\n            for (var i = 0; i < transformAxes.length; i++) {\n                var axis = transformAxes[i];\n                var key = \"rotate\" + axis;\n                // If this rotation doesn't exist as a motion value, then we don't\n                // need to reset it\n                if (!visualElement.getStaticValue(key)) {\n                    continue;\n                }\n                hasRotate = true;\n                // Record the rotation and then temporarily set it to 0\n                resetValues[key] = visualElement.getStaticValue(key);\n                visualElement.setStaticValue(key, 0);\n            }\n            // If there's no rotation values, we don't need to do any more.\n            if (!hasRotate)\n                return;\n            // Force a render of this element to apply the transform with all rotations\n            // set to 0.\n            visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n            // Put back all the values we reset\n            for (var key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        };\n        ProjectionNode.prototype.getProjectionStyles = function (styleProp) {\n            var _a, _b, _c, _d, _e, _f;\n            if (styleProp === void 0) { styleProp = {}; }\n            // TODO: Return lifecycle-persistent object\n            var styles = {};\n            if (!this.instance || this.isSVG)\n                return styles;\n            if (!this.isVisible) {\n                return { visibility: \"hidden\" };\n            }\n            else {\n                styles.visibility = \"\";\n            }\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, \"\")\n                    : \"none\";\n                return styles;\n            }\n            var lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                var emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, \"\")\n                        : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            var valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            var _g = this.projectionDelta, x = _g.x, y = _g.y;\n            styles.transformOrigin = \"\".concat(x.origin * 100, \"% \").concat(y.origin * 100, \"% 0\");\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we're not animating at all, set the lead component to its actual\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : \"\"\n                        : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (var key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;\n                var corrected = correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp.pointerEvents) || \"\"\n                        : \"none\";\n            }\n            return styles;\n        };\n        ProjectionNode.prototype.clearSnapshot = function () {\n            this.resumeFrom = this.snapshot = undefined;\n        };\n        // Only run on root\n        ProjectionNode.prototype.resetTree = function () {\n            this.root.nodes.forEach(function (node) { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        };\n        return ProjectionNode;\n    }());\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a, _b, _c, _d;\n    var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners(\"didUpdate\")) {\n        var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (node.options.animationType === \"size\") {\n            eachAxis(function (axis) {\n                var axisSnapshot = snapshot.isShared\n                    ? snapshot.measured[axis]\n                    : snapshot.layout[axis];\n                var length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout_1[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (node.options.animationType === \"position\") {\n            eachAxis(function (axis) {\n                var axisSnapshot = snapshot.isShared\n                    ? snapshot.measured[axis]\n                    : snapshot.layout[axis];\n                var length = calcLength(layout_1[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        var layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout_1, snapshot.layout);\n        var visualDelta = createDelta();\n        if (snapshot.isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout_1, snapshot.layout);\n        }\n        var hasLayoutChanged = !isDeltaZero(layoutDelta);\n        var hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            node.relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (node.relativeParent && !node.relativeParent.resumeFrom) {\n                var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;\n                if (parentSnapshot && parentLayout) {\n                    var relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);\n                    var relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);\n                    if (!boxEquals(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout: layout_1,\n            snapshot: snapshot,\n            delta: visualDelta,\n            layoutDelta: layoutDelta,\n            hasLayoutChanged: hasLayoutChanged,\n            hasRelativeTargetChanged: hasRelativeTargetChanged,\n        });\n    }\n    else if (node.isLead()) {\n        (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n    var visualElement = node.options.visualElement;\n    if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notifyBeforeLayoutMeasure();\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetRotation(node) {\n    node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mix(delta.translate, 0, p);\n    output.scale = mix(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mix(from.min, to.min, p);\n    output.max = mix(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction mountNodeEarly(node, id) {\n    /**\n     * Rather than searching the DOM from document we can search the\n     * path for the deepest mounted ancestor and search from there\n     */\n    var searchNode = node.root;\n    for (var i = node.path.length - 1; i >= 0; i--) {\n        if (Boolean(node.path[i].instance)) {\n            searchNode = node.path[i];\n            break;\n        }\n    }\n    var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n    var element = searchElement.querySelector(\"[data-projection-id=\\\"\".concat(id, \"\\\"]\"));\n    if (element)\n        node.mount(element, true);\n}\nfunction roundAxis(axis) {\n    axis.min = Math.round(axis.min);\n    axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\n\nexport { createProjectionNode, mixAxis, mixAxisDelta, mixBox };\n"],"names":["updateLayout","node","notifyLayoutUpdate","_a","_b","_c","_d","snapshot","resumeFrom","isLead","layout","hasListeners","_e","layout_1","actual","measuredLayout","measured","options","animationType","eachAxis","axis","axisSnapshot","isShared","length","calcLength","min","max","layoutDelta","createDelta","calcBoxDelta","visualDelta","applyTransform","hasLayoutChanged","isDeltaZero","hasRelativeTargetChanged","relativeParent","getClosestProjectingParent","_f","parentSnapshot","parentLayout","relativeSnapshot","createBox","calcRelativePosition","relativeLayout","boxEquals","notifyListeners","delta","onExitComplete","call","transition","undefined","clearSnapshot","clearMeasurements","resetTransformStyle","visualElement","getProps","onBeforeLayoutMeasure","notifyBeforeLayoutMeasure","resetTransform","finishAnimation","targetDelta","relativeTarget","target","resolveTargetDelta","calcProjection","resetRotation","removeLeadSnapshots","stack","removeLeadSnapshot","mixAxisDelta","output","p","translate","mix","scale","origin","originPoint","mixAxis","from","to","mixBox","x","y","hasOpacityCrossfade","animationValues","opacityExit","defaultLayoutTransition","duration","ease","mountNodeEarly","id","searchNode","root","i","path","Boolean","instance","element","document","querySelector","concat","mount","roundAxis","Math","round","roundBox","box","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","ProjectionNode","latestValues","parent","_this","this","children","Set","isTreeAnimating","isAnimationBlocked","isLayoutDirty","updateManuallyBlocked","updateBlockedByResize","isUpdating","isSVG","needsReset","shouldResetTransform","treeScale","eventHandlers","Map","potentialNodes","checkUpdateFailed","clearAllSnapshots","updateProjection","nodes","forEach","hasProjected","isVisible","animationProgress","sharedNodes","__spreadArray","__read","depth","registerPotentialNode","FlatTree","prototype","addEventListener","name","handler","has","set","SubscriptionManager","get","add","args","_i","arguments","subscriptionManager","notify","apply","SVGElement","tagName","layoutId","getInstance","delete","unblockTimeout_1","resizeUnblockUpdate_1","clearTimeout","window","setTimeout","globalProjectionState","hasAnimatedSinceResize","registerSharedNode","animate","newLayout","isTreeAnimationBlocked","layoutTransition","getDefaultTransition","_g","onLayoutAnimationStart","onLayoutAnimationComplete","targetChanged","targetLayout","hasOnlyRelativeTargetChanged","currentAnimation","resumingFrom","setAnimationOrigin","animationOptions","__assign","getValueTransition","onPlay","onComplete","shouldReduceMotion","delay","type","startAnimation","unmount","willUpdate","remove","getStack","cancelSync","preRender","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","shouldNotifyListeners","updateScroll","transformTemplate","prevTransformTemplateValue","updateSnapshot","didUpdate","size","clear","flushSync","update","render","scheduleUpdateProjection","sync","scheduleCheckAfterUnmount","postRender","measure","removeTransform","removeElementScroll","alwaysMeasureLayout","prevLayout","layoutCorrected","projectionDelta","notifyLayoutMeasure","layoutScroll","isScrollRoot","scroll","isResetRequested","hasProjection","transformTemplateValue","transformTemplateHasChanged","hasTransform","scheduleRender","measureViewportBox","translateAxis","boxWithoutScroll","copyBoxInto","scroll_1","rootScroll","transformOnly","withTransforms","transformBox","boxWithoutTransform","hasScale","sourceBox","nodeBox","removeBoxTransforms","setTargetDelta","setOptions","crossfade","relativeTargetOrigin","targetWithTransforms","calcRelativeBox","applyBoxDelta","attemptToResolveRelativeTarget","pendingAnimation","lead","getLead","applyTreeDeltas","projectionDeltaWithTransform","prevTreeScaleX","prevTreeScaleY","prevProjectionTransform","projectionTransform","buildProjectionTransform","hide","show","notifyAll","snapshotLatestValues","mixedValues","isSharedLayoutAnimation","isOnlyMember","members","shouldCrossfadeOpacity","some","mixTargetDelta","latest","progress","mixValues","stop","onUpdate","completeAnimation","preserveOpacity","exitAnimationComplete","applyTransformsToTarget","NodeStack","promote","initialPromotionConfig","preserveFollowOpacity","shouldPreserveFollowOpacity","getPrevLead","prevLead","relegate","hasRotate","resetValues","transformAxes","key","getStaticValue","setStaticValue","syncRender","getProjectionStyles","styleProp","styles","visibility","opacity","pointerEvents","resolveMotionValue","transform","emptyStyles","valuesToRender","transformOrigin","scaleCorrectors","_h","correct","applyTo","corrected","num","resetTree"],"mappings":"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"}