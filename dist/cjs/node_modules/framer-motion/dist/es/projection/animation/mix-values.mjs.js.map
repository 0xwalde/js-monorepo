{"version":3,"file":"mix-values.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"],"sourcesContent":["import { mix, progress, linear, circOut } from 'popmotion';\nimport { px, percent } from 'style-value-types';\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = function (value) {\n    return typeof value === \"string\" ? parseFloat(value) : value;\n};\nvar isPx = function (value) {\n    return typeof value === \"number\" || px.test(value);\n};\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    var _a, _b, _c, _d;\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mix(0, \n        // (follow?.opacity as number) ?? 0,\n        // TODO Reinstate this if only child\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\".concat(borders[i], \"Radius\");\n        var followRadius = getRadius(follow, borderLabel);\n        var leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        var canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n"],"names":["borders","numBorders","length","asNumber","value","parseFloat","isPx","px","test","getRadius","values","radiusName","_a","borderRadius","easeCrossfadeIn","compress","circOut","easeCrossfadeOut","linear","min","max","easing","p","progress","target","follow","lead","shouldCrossfadeOpacity","isOnlyMember","_b","_c","_d","opacity","mix","opacityExit","i","borderLabel","concat","followRadius","leadRadius","undefined","Math","percent","rotate"],"mappings":"wVAGIA,EAAU,CAAC,UAAW,WAAY,aAAc,eAChDC,EAAaD,EAAQE,OACrBC,EAAW,SAAUC,GACrB,MAAwB,iBAAVA,EAAqBC,WAAWD,GAASA,CAC3D,EACIE,EAAO,SAAUF,GACjB,MAAwB,iBAAVA,GAAsBG,EAAEA,GAACC,KAAKJ,EAChD,EA4CA,SAASK,EAAUC,EAAQC,GACvB,IAAIC,EACJ,OAAqC,QAA7BA,EAAKF,EAAOC,UAAgC,IAAPC,EAAgBA,EAAKF,EAAOG,YAC7E,CAwBA,IAAIC,EAAkBC,EAAS,EAAG,GAAKC,EAAOA,SAC1CC,EAAmBF,EAAS,GAAK,IAAMG,EAAMA,QACjD,SAASH,EAASI,EAAKC,EAAKC,GACxB,OAAO,SAAUC,GAEb,OAAIA,EAAIH,EACG,EACPG,EAAIF,EACG,EACJC,EAAOE,EAAAA,SAASJ,EAAKC,EAAKE,GACzC,CACA,mBAjFA,SAAmBE,EAAQC,EAAQC,EAAMH,EAAUI,EAAwBC,GACvE,IAAIhB,EAAIiB,EAAIC,EAAIC,EACZJ,GACAH,EAAOQ,QAAUC,EAAAA,IAAI,EAGG,QAAvBrB,EAAKc,EAAKM,eAA4B,IAAPpB,EAAgBA,EAAK,EAAGE,EAAgBS,IACxEC,EAAOU,YAAcD,EAAGA,IAA2B,QAAzBJ,EAAKJ,EAAOO,eAA4B,IAAPH,EAAgBA,EAAK,EAAG,EAAGZ,EAAiBM,KAElGK,IACLJ,EAAOQ,QAAUC,MAA8B,QAAzBH,EAAKL,EAAOO,eAA4B,IAAPF,EAAgBA,EAAK,EAA2B,QAAvBC,EAAKL,EAAKM,eAA4B,IAAPD,EAAgBA,EAAK,EAAGR,IAK3I,IAAK,IAAIY,EAAI,EAAGA,EAAIlC,EAAYkC,IAAK,CACjC,IAAIC,EAAc,SAASC,OAAOrC,EAAQmC,GAAI,UAC1CG,EAAe7B,EAAUgB,EAAQW,GACjCG,EAAa9B,EAAUiB,EAAMU,GACjC,QAAqBI,IAAjBF,QAA6CE,IAAfD,EAElCD,IAAiBA,EAAe,GAChCC,IAAeA,EAAa,GACE,IAAjBD,GACM,IAAfC,GACAjC,EAAKgC,KAAkBhC,EAAKiC,IAE5Bf,EAAOY,GAAeK,KAAKrB,IAAIa,EAAGA,IAAC9B,EAASmC,GAAenC,EAASoC,GAAahB,GAAW,IACxFmB,EAAAA,QAAQlC,KAAK+B,IAAeG,EAAAA,QAAQlC,KAAK8B,MACzCd,EAAOY,IAAgB,MAI3BZ,EAAOY,GAAeG,CAE7B,EAIGd,EAAOkB,QAAUjB,EAAKiB,UACtBnB,EAAOmB,OAASV,MAAIR,EAAOkB,QAAU,EAAGjB,EAAKiB,QAAU,EAAGpB,GAElE"}