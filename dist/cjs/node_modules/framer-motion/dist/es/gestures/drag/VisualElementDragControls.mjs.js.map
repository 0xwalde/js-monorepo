{"version":3,"file":"VisualElementDragControls.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs"],"sourcesContent":["import { __assign } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { PanSession } from '../PanSession.mjs';\nimport { getGlobalLock } from './utils/lock.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { addPointerEvent } from '../../events/use-pointer-event.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\nimport { AnimationType } from '../../render/utils/types.mjs';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\nimport { addDomEvent } from '../../events/use-dom-event.mjs';\nimport { mix } from 'popmotion';\nimport { percent } from 'style-value-types';\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: AnyPointerEvent\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(visualElement) {\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        if (this.visualElement.isPresent === false)\n            return;\n        var onSessionStart = function (event) {\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopAnimation();\n            if (snapToCursor) {\n                _this.snapToCursor(extractEventInfo(event, \"page\").point);\n            }\n        };\n        var onStart = function (event, info) {\n            var _a;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _b = _this.getProps(), drag = _b.drag, dragPropagation = _b.dragPropagation, onDragStart = _b.onDragStart;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            _this.resolveConstraints();\n            if (_this.visualElement.projection) {\n                _this.visualElement.projection.isAnimationBlocked = true;\n                _this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis(function (axis) {\n                var _a, _b;\n                var current = _this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    var measuredAxis = (_b = (_a = _this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];\n                    if (measuredAxis) {\n                        var length_1 = calcLength(measuredAxis);\n                        current = length_1 * (parseFloat(current) / 100);\n                    }\n                }\n                _this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n            (_a = _this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            // latestPointerEvent = event\n            var _a = _this.getProps(), dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock, onDirectionLock = _a.onDirectionLock, onDrag = _a.onDrag;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            _this.visualElement.syncRender();\n            /**\n             * This must fire after the syncRender call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.startAnimation(velocity);\n        var onDragEnd = this.getProps().onDragEnd;\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n    };\n    VisualElementDragControls.prototype.cancel = function () {\n        var _a, _b;\n        this.isDragging = false;\n        if (this.visualElement.projection) {\n            this.visualElement.projection.isAnimationBlocked = false;\n        }\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = undefined;\n        var dragPropagation = this.getProps().dragPropagation;\n        if (!dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.updateAxis = function (axis, _point, offset) {\n        var drag = this.getProps().drag;\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        var axisValue = this.getAxisMotionValue(axis);\n        var next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    };\n    VisualElementDragControls.prototype.resolveConstraints = function () {\n        var _this = this;\n        var _a = this.getProps(), dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = (this.visualElement.projection || {}).layout;\n        var prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function () {\n        var _a = this.getProps(), constraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints;\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        var constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        var projection = this.visualElement.projection;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.startAnimation = function (velocity) {\n        var _this = this;\n        var _a = this.getProps(), drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, dragSnapToOrigin = _a.dragSnapToOrigin, onDragTransitionEnd = _a.onDragTransitionEnd;\n        var constraints = this.constraints || {};\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = __assign(__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness, bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.stopAnimation = function () {\n        var _this = this;\n        eachAxis(function (axis) { return _this.getAxisMotionValue(axis).stop(); });\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a, _b;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        var externalMotionValue = this.visualElement.getProps()[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        eachAxis(function (axis) {\n            var drag = _this.getProps().drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var projection = _this.visualElement.projection;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                var _a = projection.layout.actual[axis], min = _a.min, max = _a.max;\n                axisValue.set(point[axis] - mix(min, max, 0.5));\n            }\n        });\n    };\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    VisualElementDragControls.prototype.scalePositionWithinConstraints = function () {\n        var _this = this;\n        var _a;\n        var _b = this.getProps(), drag = _b.drag, dragConstraints = _b.dragConstraints;\n        var projection = this.visualElement.projection;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, _this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        var transformTemplate = this.visualElement.getProps().transformTemplate;\n        this.visualElement.getInstance().style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis(function (axis) {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            var axisValue = _this.getAxisMotionValue(axis);\n            var _a = _this.constraints[axis], min = _a.min, max = _a.max;\n            axisValue.set(mix(min, max, boxProgress[axis]));\n        });\n    };\n    VisualElementDragControls.prototype.addListeners = function () {\n        var _this = this;\n        var _a;\n        elementDragControls.set(this.visualElement, this);\n        var element = this.visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.getProps(), drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        var measureDragConstraints = function () {\n            var dragConstraints = _this.getProps().dragConstraints;\n            if (isRefObject(dragConstraints)) {\n                _this.constraints = _this.resolveRefConstraints();\n            }\n        };\n        var projection = this.visualElement.projection;\n        var stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n            projection.updateLayout();\n        }\n        measureDragConstraints();\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            return _this.scalePositionWithinConstraints();\n        });\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        projection.addEventListener(\"didUpdate\", (function (_a) {\n            var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged;\n            if (_this.isDragging && hasLayoutChanged) {\n                eachAxis(function (axis) {\n                    var motionValue = _this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    _this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                _this.visualElement.syncRender();\n            }\n        }));\n        return function () {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n        };\n    };\n    VisualElementDragControls.prototype.getProps = function () {\n        var props = this.visualElement.getProps();\n        var _a = props.drag, drag = _a === void 0 ? false : _a, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e = props.dragElastic, dragElastic = _e === void 0 ? defaultElastic : _e, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;\n        return __assign(__assign({}, props), { drag: drag, dragDirectionLock: dragDirectionLock, dragPropagation: dragPropagation, dragConstraints: dragConstraints, dragElastic: dragElastic, dragMomentum: dragMomentum });\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n"],"names":["elementDragControls","WeakMap","VisualElementDragControls","visualElement","this","openGlobalLock","isDragging","currentDirection","originPoint","x","y","constraints","hasMutatedConstraints","elastic","createBox","prototype","start","originEvent","_a","_this","_c","snapToCursor","isPresent","panSession","PanSession","onSessionStart","event","stopAnimation","extractEventInfo","point","onStart","info","_b","getProps","drag","dragPropagation","onDragStart","getGlobalLock","resolveConstraints","projection","isAnimationBlocked","target","undefined","eachAxis","axis","current","getAxisMotionValue","get","percent","test","measuredAxis","layout","actual","calcLength","parseFloat","animationState","setActive","AnimationType","Drag","onMove","dragDirectionLock","onDirectionLock","onDrag","offset","lockThreshold","direction","Math","abs","getCurrentDirection","updateAxis","syncRender","onSessionEnd","stop","transformPagePoint","getTransformPagePoint","cancel","velocity","startAnimation","onDragEnd","end","_point","shouldDrag","axisValue","next","applyConstraints","set","dragConstraints","dragElastic","prevConstraints","isRefObject","resolveRefConstraints","calcRelativeConstraints","resolveDragElastic","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","invariant","constraintsBox","measurePageBox","root","measuredConstraints","calcViewportConstraints","userConstraints","convertBoxToBoundingBox","convertBoundingBoxToBox","dragMomentum","dragTransition","dragSnapToOrigin","onDragTransitionEnd","momentumAnimations","transition","min","max","bounceStiffness","bounceDamping","inertia","__assign","type","timeConstant","restDelta","restSpeed","startAxisValueAnimation","Promise","all","then","dragKey","toUpperCase","externalMotionValue","getValue","initial","mix","scalePositionWithinConstraints","boxProgress","latest","calcOrigin","transformTemplate","getInstance","style","transform","updateScroll","updateLayout","addListeners","element","stopPointerListener","addPointerEvent","dragListener","measureDragConstraints","stopMeasureLayoutListener","addEventListener","stopResizeListener","addDomEvent","window","delta","hasLayoutChanged","motionValue","translate","props","_d","_e","defaultElastic","_f"],"mappings":"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"}