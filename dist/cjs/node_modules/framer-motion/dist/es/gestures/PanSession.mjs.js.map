{"version":3,"file":"PanSession.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/gestures/PanSession.mjs"],"sourcesContent":["import { __assign } from 'tslib';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { distance, pipe } from 'popmotion';\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync.update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"names":["PanSession","event","handlers","_a","_this","this","transformPagePoint","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","distance","offset","x","y","point","timestamp","getFrameData","push","__assign","onStart","onMove","handlePointerMove","transformPoint","isMouseEvent","buttons","handlePointerUp","sync","update","end","onEnd","onSessionEnd","panInfo","isTouchEvent","touches","length","initialInfo","extractEventInfo","onSessionStart","removeListeners","pipe","addPointerEvent","window","prototype","updateHandlers","cancelSync","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","secondsToMilliseconds","time","currentVelocity","Infinity"],"mappings":"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"}