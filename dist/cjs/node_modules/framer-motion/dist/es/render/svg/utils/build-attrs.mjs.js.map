{"version":3,"file":"build-attrs.mjs.js","sources":["../../../../../../../../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs"],"sourcesContent":["import { __rest } from 'tslib';\nimport { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\nimport { calcSVGTransformOrigin } from './transform-origin.mjs';\nimport { buildSVGPath } from './path.mjs';\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, options, transformTemplate) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nexport { buildSVGAttrs };\n"],"names":["state","_a","options","transformTemplate","attrX","attrY","originX","originY","pathLength","_b","pathSpacing","_c","pathOffset","latest","__rest","buildHTMLStyles","attrs","style","dimensions","transform","undefined","transformOrigin","calcSVGTransformOrigin","x","y","buildSVGPath"],"mappings":"oQAQA,SAAuBA,EAAOC,EAAIC,EAASC,GACvC,IAAIC,EAAQH,EAAGG,MAAOC,EAAQJ,EAAGI,MAAOC,EAAUL,EAAGK,QAASC,EAAUN,EAAGM,QAASC,EAAaP,EAAGO,WAAYC,EAAKR,EAAGS,YAAaA,OAAqB,IAAPD,EAAgB,EAAIA,EAAIE,EAAKV,EAAGW,WAAYA,OAAoB,IAAPD,EAAgB,EAAIA,EAEhOE,EAASC,EAAMA,OAACb,EAAI,CAAC,QAAS,QAAS,UAAW,UAAW,aAAc,cAAe,eAC1Fc,EAAAA,gBAAgBf,EAAOa,EAAQX,EAASC,GACxCH,EAAMgB,MAAQhB,EAAMiB,MACpBjB,EAAMiB,MAAQ,GACd,IAAID,EAAQhB,EAAMgB,MAAOC,EAAQjB,EAAMiB,MAAOC,EAAalB,EAAMkB,WAK7DF,EAAMG,YACFD,IACAD,EAAME,UAAYH,EAAMG,kBACrBH,EAAMG,WAGbD,SACaE,IAAZd,QAAqCc,IAAZb,GAAyBU,EAAME,aACzDF,EAAMI,gBAAkBC,EAAAA,uBAAuBJ,OAAwBE,IAAZd,EAAwBA,EAAU,QAAiBc,IAAZb,EAAwBA,EAAU,UAG1Ha,IAAVhB,IACAY,EAAMO,EAAInB,QACAgB,IAAVf,IACAW,EAAMQ,EAAInB,QAEKe,IAAfZ,GACAiB,EAAYA,aAACT,EAAOR,EAAYE,EAAaE,GAAY,EAEjE"}