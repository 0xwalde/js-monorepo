{"version":3,"file":"css-variables-conversion.mjs.js","sources":["../../../../../../../../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs"],"sourcesContent":["import { __rest, __assign, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = __read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\".concat(current, \"\\\". This may indicate a circular fallback dependency.\"));\n    var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = __rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof Element))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = __assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nexport { cssVariableRegex, parseCSSVariable, resolveCSSVariables };\n"],"names":["isCSSVariable","value","startsWith","cssVariableRegex","parseCSSVariable","current","match","exec","_a","__read","getVariableValue","element","depth","invariant","concat","token","fallback","resolved","window","getComputedStyle","getPropertyValue","trim","visualElement","transitionEnd","_b","target","__rest","getInstance","Element","key","__assign","forEachValue","get","set"],"mappings":"0LAGA,SAASA,EAAcC,GACnB,MAAwB,iBAAVA,GAAsBA,EAAMC,WAAW,SACzD,CAUG,IAACC,EAAmB,uDACvB,SAASC,EAAiBC,GACtB,IAAIC,EAAQH,EAAiBI,KAAKF,GAClC,IAAKC,EACD,MAAO,IACX,IAAIE,EAAKC,EAAAA,OAAOH,EAAO,GACvB,MAAO,CAD4BE,EAAG,GAAeA,EAAG,GAE5D,CAEA,SAASE,EAAiBL,EAASM,EAASC,QAC1B,IAAVA,IAAoBA,EAAQ,GAChCC,EAASA,UAACD,GAHC,EAGkB,yDAA0DE,OAAOT,EAAS,yDACvG,IAAIG,EAAKC,EAAMA,OAACL,EAAiBC,GAAU,GAAIU,EAAQP,EAAG,GAAIQ,EAAWR,EAAG,GAE5E,GAAKO,EAAL,CAGA,IAAIE,EAAWC,OAAOC,iBAAiBR,GAASS,iBAAiBL,GACjE,OAAIE,EACOA,EAASI,OAEXrB,EAAcgB,GAEZN,EAAiBM,EAAUL,EAASC,EAAQ,GAG5CI,CAXA,CAaf,mFAMA,SAA6BM,EAAed,EAAIe,GAC5C,IAAIC,EACAC,EAASC,EAAAA,OAAOlB,EAAI,IACpBG,EAAUW,EAAcK,cAC5B,KAAMhB,aAAmBiB,SACrB,MAAO,CAAEH,OAAQA,EAAQF,cAAeA,GAiB5C,IAAK,IAAIM,KAdLN,IACAA,EAAgBO,EAAQA,SAAC,GAAIP,IAGjCD,EAAcS,cAAa,SAAU9B,GACjC,IAAII,EAAUJ,EAAM+B,MACpB,GAAKhC,EAAcK,GAAnB,CAEA,IAAIY,EAAWP,EAAiBL,EAASM,GACrCM,GACAhB,EAAMgC,IAAIhB,EAHH,CAInB,IAGoBQ,EAAQ,CACpB,IAAIpB,EAAUoB,EAAOI,GACrB,GAAK7B,EAAcK,GAAnB,CAEA,IAAIY,EAAWP,EAAiBL,EAASM,GACpCM,IAGLQ,EAAOI,GAAOZ,EAIVM,IAC8B,QAA7BC,EAAKD,EAAcM,UAAyB,IAAPL,IAAsBD,EAAcM,GAAOxB,IAVxE,CAWhB,CACD,MAAO,CAAEoB,OAAQA,EAAQF,cAAeA,EAC5C"}