{"version":3,"file":"observers.mjs.js","sources":["../../../../../../../../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["import { __rest, __assign } from 'tslib';\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nvar observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nvar observers = new WeakMap();\nvar fireObserverCallback = function (entry) {\n    var _a;\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nvar fireAllObserverCallbacks = function (entries) {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n    var root = _a.root, options = __rest(_a, [\"root\"]);\n    var lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    var rootObservers = observers.get(lookupRoot);\n    var key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root: root }, options));\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    var rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return function () {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","_a","get","target","fireAllObserverCallbacks","entries","forEach","observeIntersection","element","options","callback","rootInteresectionObserver","root","__rest","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","__assign","initIntersectionObserver","observe","delete","unobserve"],"mappings":"4EAOA,IAAIA,EAAoB,IAAIC,QAMxBC,EAAY,IAAID,QAChBE,EAAuB,SAAUC,GACjC,IAAIC,EAC2C,QAA9CA,EAAKL,EAAkBM,IAAIF,EAAMG,eAA4B,IAAPF,GAAyBA,EAAGD,EACvF,EACII,EAA2B,SAAUC,GACrCA,EAAQC,QAAQP,EACpB,EAqBA,SAASQ,EAAoBC,EAASC,EAASC,GAC3C,IAAIC,EArBR,SAAkCV,GAC9B,IAAIW,EAAOX,EAAGW,KAAMH,EAAUI,EAAOZ,EAAI,CAAC,SACtCa,EAAaF,GAAQG,SAIpBjB,EAAUkB,IAAIF,IACfhB,EAAUmB,IAAIH,EAAY,CAAA,GAE9B,IAAII,EAAgBpB,EAAUI,IAAIY,GAC9BK,EAAMC,KAAKC,UAAUZ,GAQzB,OAHKS,EAAcC,KACfD,EAAcC,GAAO,IAAIG,qBAAqBlB,EAA0BmB,EAAS,CAAEX,KAAMA,GAAQH,KAE9FS,EAAcC,EACzB,CAEoCK,CAAyBf,GAGzD,OAFAb,EAAkBqB,IAAIT,EAASE,GAC/BC,EAA0Bc,QAAQjB,GAC3B,WACHZ,EAAkB8B,OAAOlB,GACzBG,EAA0BgB,UAAUnB,EAC5C,CACA"}