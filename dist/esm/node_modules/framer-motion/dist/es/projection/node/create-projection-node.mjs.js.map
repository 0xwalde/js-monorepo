{"version":3,"file":"create-projection-node.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs"],"sourcesContent":["import { __spreadArray, __read, __assign } from 'tslib';\nimport sync, { cancelSync, flushSync } from 'framesync';\nimport { mix } from 'popmotion';\nimport { animate } from '../../animation/animate.mjs';\nimport { SubscriptionManager } from '../../utils/subscription-manager.mjs';\nimport { mixValues } from '../animation/mix-values.mjs';\nimport { copyBoxInto } from '../geometry/copy.mjs';\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\nimport { calcRelativePosition, calcRelativeBox, calcBoxDelta, calcLength } from '../geometry/delta-calc.mjs';\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\nimport { createBox, createDelta } from '../geometry/models.mjs';\nimport { getValueTransition } from '../../animation/utils/transitions.mjs';\nimport { boxEquals, isDeltaZero } from '../geometry/utils.mjs';\nimport { NodeStack } from '../shared/stack.mjs';\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\nimport { buildProjectionTransform } from '../styles/transform.mjs';\nimport { eachAxis } from '../utils/each-axis.mjs';\nimport { hasTransform, hasScale } from '../utils/has-transform.mjs';\nimport { transformAxes } from '../../render/html/utils/transform.mjs';\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { globalProjectionState } from './state.mjs';\n\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nvar animationTarget = 1000;\nfunction createProjectionNode(_a) {\n    var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, checkIsScrollRoot = _a.checkIsScrollRoot, resetTransform = _a.resetTransform;\n    return /** @class */ (function () {\n        function ProjectionNode(id, latestValues, parent) {\n            var _this = this;\n            if (latestValues === void 0) { latestValues = {}; }\n            if (parent === void 0) { parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent(); }\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to actually\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            // Note: Currently only running on root node\n            this.potentialNodes = new Map();\n            this.checkUpdateFailed = function () {\n                if (_this.isUpdating) {\n                    _this.isUpdating = false;\n                    _this.clearAllSnapshots();\n                }\n            };\n            this.updateProjection = function () {\n                _this.nodes.forEach(resolveTargetDelta);\n                _this.nodes.forEach(calcProjection);\n            };\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.id = id;\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            id && this.root.registerPotentialNode(id, this);\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        ProjectionNode.prototype.addEventListener = function (name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        };\n        ProjectionNode.prototype.notifyListeners = function (name) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));\n        };\n        ProjectionNode.prototype.hasListeners = function (name) {\n            return this.eventHandlers.has(name);\n        };\n        ProjectionNode.prototype.registerPotentialNode = function (id, node) {\n            this.potentialNodes.set(id, node);\n        };\n        /**\n         * Lifecycles\n         */\n        ProjectionNode.prototype.mount = function (instance, isLayoutDirty) {\n            var _this = this;\n            var _a;\n            if (isLayoutDirty === void 0) { isLayoutDirty = false; }\n            if (this.instance)\n                return;\n            this.isSVG =\n                instance instanceof SVGElement && instance.tagName !== \"svg\";\n            this.instance = instance;\n            var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement = _b.visualElement;\n            if (visualElement && !visualElement.getInstance()) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n            this.id && this.root.potentialNodes.delete(this.id);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                var unblockTimeout_1;\n                var resizeUnblockUpdate_1 = function () {\n                    return (_this.root.updateBlockedByResize = false);\n                };\n                attachResizeListener(instance, function () {\n                    _this.root.updateBlockedByResize = true;\n                    clearTimeout(unblockTimeout_1);\n                    unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        _this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", function (_a) {\n                    var _b, _c, _d, _e, _f;\n                    var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged, hasRelativeTargetChanged = _a.hasRelativeTargetChanged, newLayout = _a.layout;\n                    if (_this.isTreeAnimationBlocked()) {\n                        _this.target = undefined;\n                        _this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    var layoutTransition = (_c = (_b = _this.options.transition) !== null && _b !== void 0 ? _b : visualElement.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;\n                    var _g = visualElement.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    var targetChanged = !_this.targetLayout ||\n                        !boxEquals(_this.targetLayout, newLayout) ||\n                        hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (targetChanged || !_this.currentAnimation))) {\n                        if (_this.resumeFrom) {\n                            _this.resumingFrom = _this.resumeFrom;\n                            _this.resumingFrom.resumingFrom = undefined;\n                        }\n                        _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, \"layout\")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });\n                        if (visualElement.shouldReduceMotion) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        _this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged &&\n                            _this.animationProgress === 0) {\n                            _this.finishAnimation();\n                        }\n                        _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));\n                    }\n                    _this.targetLayout = newLayout;\n                });\n            }\n        };\n        ProjectionNode.prototype.unmount = function () {\n            var _a, _b;\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n            (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n            this.instance = undefined;\n            cancelSync.preRender(this.updateProjection);\n        };\n        // only on the root\n        ProjectionNode.prototype.blockUpdate = function () {\n            this.updateManuallyBlocked = true;\n        };\n        ProjectionNode.prototype.unblockUpdate = function () {\n            this.updateManuallyBlocked = false;\n        };\n        ProjectionNode.prototype.isUpdateBlocked = function () {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        };\n        ProjectionNode.prototype.isTreeAnimationBlocked = function () {\n            var _a;\n            return (this.isAnimationBlocked ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) ||\n                false);\n        };\n        // Note: currently only running on root node\n        ProjectionNode.prototype.startUpdate = function () {\n            var _a;\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n        };\n        ProjectionNode.prototype.willUpdate = function (shouldNotifyListeners) {\n            var _a, _b, _c;\n            if (shouldNotifyListeners === void 0) { shouldNotifyListeners = true; }\n            if (this.root.isUpdateBlocked()) {\n                (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n                return;\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                node.shouldResetTransform = true;\n                /**\n                 * TODO: Check we haven't updated the scroll\n                 * since the last didUpdate\n                 */\n                node.updateScroll();\n            }\n            var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;\n            if (layoutId === undefined && !layout)\n                return;\n            var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n            this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        };\n        // Note: Currently only running on root node\n        ProjectionNode.prototype.didUpdate = function () {\n            var updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating)\n                return;\n            this.isUpdating = false;\n            /**\n             * Search for and mount newly-added projection elements.\n             *\n             * TODO: Every time a new component is rendered we could search up the tree for\n             * the closest mounted node and query from there rather than document.\n             */\n            if (this.potentialNodes.size) {\n                this.potentialNodes.forEach(mountNodeEarly);\n                this.potentialNodes.clear();\n            }\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            // Flush any scheduled updates\n            flushSync.update();\n            flushSync.preRender();\n            flushSync.render();\n        };\n        ProjectionNode.prototype.clearAllSnapshots = function () {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        };\n        ProjectionNode.prototype.scheduleUpdateProjection = function () {\n            sync.preRender(this.updateProjection, false, true);\n        };\n        ProjectionNode.prototype.scheduleCheckAfterUnmount = function () {\n            var _this = this;\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            sync.postRender(function () {\n                if (_this.isLayoutDirty) {\n                    _this.root.didUpdate();\n                }\n                else {\n                    _this.root.checkUpdateFailed();\n                }\n            });\n        };\n        /**\n         * Update measurements\n         */\n        ProjectionNode.prototype.updateSnapshot = function () {\n            if (this.snapshot || !this.instance)\n                return;\n            var measured = this.measure();\n            var layout = this.removeTransform(this.removeElementScroll(measured));\n            roundBox(layout);\n            this.snapshot = {\n                measured: measured,\n                layout: layout,\n                latestValues: {},\n            };\n        };\n        ProjectionNode.prototype.updateLayout = function () {\n            var _a;\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (var i = 0; i < this.path.length; i++) {\n                    var node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            var measured = this.measure();\n            roundBox(measured);\n            var prevLayout = this.layout;\n            this.layout = {\n                measured: measured,\n                actual: this.removeElementScroll(measured),\n            };\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.actual);\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);\n        };\n        ProjectionNode.prototype.updateScroll = function () {\n            if (this.options.layoutScroll && this.instance) {\n                this.isScrollRoot = checkIsScrollRoot(this.instance);\n                this.scroll = measureScroll(this.instance);\n            }\n        };\n        ProjectionNode.prototype.resetTransform = function () {\n            var _a;\n            if (!resetTransform)\n                return;\n            var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n            var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        };\n        ProjectionNode.prototype.measure = function () {\n            var visualElement = this.options.visualElement;\n            if (!visualElement)\n                return createBox();\n            var box = visualElement.measureViewportBox();\n            // Remove viewport scroll to give page-relative coordinates\n            var scroll = this.root.scroll;\n            if (scroll) {\n                translateAxis(box.x, scroll.x);\n                translateAxis(box.y, scroll.y);\n            }\n            return box;\n        };\n        ProjectionNode.prototype.removeElementScroll = function (box) {\n            var boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;\n                if (node !== this.root && scroll_1 && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (isScrollRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                        var rootScroll = this.root.scroll;\n                        /**\n                         * Undo the application of page scroll that was originally added\n                         * to the measured bounding box.\n                         */\n                        if (rootScroll) {\n                            translateAxis(boxWithoutScroll.x, -rootScroll.x);\n                            translateAxis(boxWithoutScroll.y, -rootScroll.y);\n                        }\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll_1.x);\n                    translateAxis(boxWithoutScroll.y, scroll_1.y);\n                }\n            }\n            return boxWithoutScroll;\n        };\n        ProjectionNode.prototype.applyTransform = function (box, transformOnly) {\n            if (transformOnly === void 0) { transformOnly = false; }\n            var withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.x,\n                        y: -node.scroll.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        };\n        ProjectionNode.prototype.removeTransform = function (box) {\n            var _a;\n            var boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                var sourceBox = createBox();\n                var nodeBox = node.measure();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        };\n        /**\n         *\n         */\n        ProjectionNode.prototype.setTargetDelta = function (delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n        };\n        ProjectionNode.prototype.setOptions = function (options) {\n            var _a;\n            this.options = __assign(__assign(__assign({}, this.options), options), { crossfade: (_a = options.crossfade) !== null && _a !== void 0 ? _a : true });\n        };\n        ProjectionNode.prototype.clearMeasurements = function () {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        };\n        /**\n         * Frame calculations\n         */\n        ProjectionNode.prototype.resolveTargetDelta = function () {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            // TODO If this is unsuccessful this currently happens every frame\n            if (!this.targetDelta && !this.relativeTarget) {\n                // TODO: This is a semi-repetition of further down this function, make DRY\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && this.relativeParent.layout) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.actual);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.actual);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.actual);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent &&\n                    Boolean(this.relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !this.relativeParent.options.layoutScroll &&\n                    this.relativeParent.target) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n        };\n        ProjectionNode.prototype.getClosestProjectingParent = function () {\n            if (!this.parent || hasTransform(this.parent.latestValues))\n                return undefined;\n            if ((this.parent.relativeTarget || this.parent.targetDelta) &&\n                this.parent.layout) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        };\n        ProjectionNode.prototype.calcProjection = function () {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            var lead = this.getLead();\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.actual);\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n            var target = lead.target;\n            if (!target)\n                return;\n            if (!this.projectionDelta) {\n                this.projectionDelta = createDelta();\n                this.projectionDeltaWithTransform = createDelta();\n            }\n            var prevTreeScaleX = this.treeScale.x;\n            var prevTreeScaleY = this.treeScale.y;\n            var prevProjectionTransform = this.projectionTransform;\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n            if (this.projectionTransform !== prevProjectionTransform ||\n                this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n        };\n        ProjectionNode.prototype.hide = function () {\n            this.isVisible = false;\n            // TODO: Schedule render\n        };\n        ProjectionNode.prototype.show = function () {\n            this.isVisible = true;\n            // TODO: Schedule render\n        };\n        ProjectionNode.prototype.scheduleRender = function (notifyAll) {\n            var _a, _b, _c;\n            if (notifyAll === void 0) { notifyAll = true; }\n            (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n            notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        };\n        ProjectionNode.prototype.setAnimationOrigin = function (delta, hasOnlyRelativeTargetChanged) {\n            var _this = this;\n            var _a;\n            if (hasOnlyRelativeTargetChanged === void 0) { hasOnlyRelativeTargetChanged = false; }\n            var snapshot = this.snapshot;\n            var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n            var mixedValues = __assign({}, this.latestValues);\n            var targetDelta = createDelta();\n            this.relativeTarget = this.relativeTargetOrigin = undefined;\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            var relativeLayout = createBox();\n            var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n            var isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n            var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            this.mixTargetDelta = function (latest) {\n                var _a;\n                var progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                _this.setTargetDelta(targetDelta);\n                if (_this.relativeTarget &&\n                    _this.relativeTargetOrigin &&\n                    _this.layout &&\n                    ((_a = _this.relativeParent) === null || _a === void 0 ? void 0 : _a.layout)) {\n                    calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);\n                    mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress);\n                }\n                if (isSharedLayoutAnimation) {\n                    _this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                _this.root.scheduleUpdateProjection();\n                _this.scheduleRender();\n                _this.animationProgress = progress;\n            };\n            this.mixTargetDelta(0);\n        };\n        ProjectionNode.prototype.startAnimation = function (options) {\n            var _this = this;\n            var _a, _b;\n            this.notifyListeners(\"animationStart\");\n            (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            if (this.resumingFrom) {\n                (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelSync.update(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = sync.update(function () {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                _this.currentAnimation = animate(0, animationTarget, __assign(__assign({}, options), { onUpdate: function (latest) {\n                        var _a;\n                        _this.mixTargetDelta(latest);\n                        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, latest);\n                    }, onComplete: function () {\n                        var _a;\n                        (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options);\n                        _this.completeAnimation();\n                    } }));\n                if (_this.resumingFrom) {\n                    _this.resumingFrom.currentAnimation = _this.currentAnimation;\n                }\n                _this.pendingAnimation = undefined;\n            });\n        };\n        ProjectionNode.prototype.completeAnimation = function () {\n            var _a;\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners(\"animationComplete\");\n        };\n        ProjectionNode.prototype.finishAnimation = function () {\n            var _a;\n            if (this.currentAnimation) {\n                (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        };\n        ProjectionNode.prototype.applyTransformsToTarget = function () {\n            var _a = this.getLead(), targetWithTransforms = _a.targetWithTransforms, target = _a.target, layout = _a.layout, latestValues = _a.latestValues;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its actual layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        };\n        ProjectionNode.prototype.registerSharedNode = function (layoutId, node) {\n            var _a, _b, _c;\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            var stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            node.promote({\n                transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n                preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node),\n            });\n        };\n        ProjectionNode.prototype.isLead = function () {\n            var stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        };\n        ProjectionNode.prototype.getLead = function () {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        };\n        ProjectionNode.prototype.getPrevLead = function () {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        };\n        ProjectionNode.prototype.getStack = function () {\n            var layoutId = this.options.layoutId;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        };\n        ProjectionNode.prototype.promote = function (_a) {\n            var _b = _a === void 0 ? {} : _a, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;\n            var stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition: transition });\n        };\n        ProjectionNode.prototype.relegate = function () {\n            var stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        };\n        ProjectionNode.prototype.resetRotation = function () {\n            var visualElement = this.options.visualElement;\n            if (!visualElement)\n                return;\n            // If there's no detected rotation values, we can early return without a forced render.\n            var hasRotate = false;\n            // Keep a record of all the values we've reset\n            var resetValues = {};\n            // Check the rotate value of all axes and reset to 0\n            for (var i = 0; i < transformAxes.length; i++) {\n                var axis = transformAxes[i];\n                var key = \"rotate\" + axis;\n                // If this rotation doesn't exist as a motion value, then we don't\n                // need to reset it\n                if (!visualElement.getStaticValue(key)) {\n                    continue;\n                }\n                hasRotate = true;\n                // Record the rotation and then temporarily set it to 0\n                resetValues[key] = visualElement.getStaticValue(key);\n                visualElement.setStaticValue(key, 0);\n            }\n            // If there's no rotation values, we don't need to do any more.\n            if (!hasRotate)\n                return;\n            // Force a render of this element to apply the transform with all rotations\n            // set to 0.\n            visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n            // Put back all the values we reset\n            for (var key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        };\n        ProjectionNode.prototype.getProjectionStyles = function (styleProp) {\n            var _a, _b, _c, _d, _e, _f;\n            if (styleProp === void 0) { styleProp = {}; }\n            // TODO: Return lifecycle-persistent object\n            var styles = {};\n            if (!this.instance || this.isSVG)\n                return styles;\n            if (!this.isVisible) {\n                return { visibility: \"hidden\" };\n            }\n            else {\n                styles.visibility = \"\";\n            }\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, \"\")\n                    : \"none\";\n                return styles;\n            }\n            var lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                var emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, \"\")\n                        : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            var valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            var _g = this.projectionDelta, x = _g.x, y = _g.y;\n            styles.transformOrigin = \"\".concat(x.origin * 100, \"% \").concat(y.origin * 100, \"% 0\");\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we're not animating at all, set the lead component to its actual\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : \"\"\n                        : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (var key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;\n                var corrected = correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp.pointerEvents) || \"\"\n                        : \"none\";\n            }\n            return styles;\n        };\n        ProjectionNode.prototype.clearSnapshot = function () {\n            this.resumeFrom = this.snapshot = undefined;\n        };\n        // Only run on root\n        ProjectionNode.prototype.resetTree = function () {\n            this.root.nodes.forEach(function (node) { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        };\n        return ProjectionNode;\n    }());\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a, _b, _c, _d;\n    var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners(\"didUpdate\")) {\n        var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (node.options.animationType === \"size\") {\n            eachAxis(function (axis) {\n                var axisSnapshot = snapshot.isShared\n                    ? snapshot.measured[axis]\n                    : snapshot.layout[axis];\n                var length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout_1[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (node.options.animationType === \"position\") {\n            eachAxis(function (axis) {\n                var axisSnapshot = snapshot.isShared\n                    ? snapshot.measured[axis]\n                    : snapshot.layout[axis];\n                var length = calcLength(layout_1[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        var layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout_1, snapshot.layout);\n        var visualDelta = createDelta();\n        if (snapshot.isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout_1, snapshot.layout);\n        }\n        var hasLayoutChanged = !isDeltaZero(layoutDelta);\n        var hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            node.relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (node.relativeParent && !node.relativeParent.resumeFrom) {\n                var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;\n                if (parentSnapshot && parentLayout) {\n                    var relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);\n                    var relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);\n                    if (!boxEquals(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout: layout_1,\n            snapshot: snapshot,\n            delta: visualDelta,\n            layoutDelta: layoutDelta,\n            hasLayoutChanged: hasLayoutChanged,\n            hasRelativeTargetChanged: hasRelativeTargetChanged,\n        });\n    }\n    else if (node.isLead()) {\n        (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n    var visualElement = node.options.visualElement;\n    if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notifyBeforeLayoutMeasure();\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetRotation(node) {\n    node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mix(delta.translate, 0, p);\n    output.scale = mix(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mix(from.min, to.min, p);\n    output.max = mix(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction mountNodeEarly(node, id) {\n    /**\n     * Rather than searching the DOM from document we can search the\n     * path for the deepest mounted ancestor and search from there\n     */\n    var searchNode = node.root;\n    for (var i = node.path.length - 1; i >= 0; i--) {\n        if (Boolean(node.path[i].instance)) {\n            searchNode = node.path[i];\n            break;\n        }\n    }\n    var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n    var element = searchElement.querySelector(\"[data-projection-id=\\\"\".concat(id, \"\\\"]\"));\n    if (element)\n        node.mount(element, true);\n}\nfunction roundAxis(axis) {\n    axis.min = Math.round(axis.min);\n    axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\n\nexport { createProjectionNode, mixAxis, mixAxisDelta, mixBox };\n"],"names":["createProjectionNode","_a","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","resetTransform","ProjectionNode","id","latestValues","parent","_this","this","children","Set","options","isTreeAnimating","isAnimationBlocked","isLayoutDirty","updateManuallyBlocked","updateBlockedByResize","isUpdating","isSVG","needsReset","shouldResetTransform","treeScale","x","y","eventHandlers","Map","potentialNodes","checkUpdateFailed","clearAllSnapshots","updateProjection","nodes","forEach","resolveTargetDelta","calcProjection","hasProjected","isVisible","animationProgress","sharedNodes","root","path","__spreadArray","__read","depth","registerPotentialNode","i","length","FlatTree","prototype","addEventListener","name","handler","has","set","SubscriptionManager","get","add","notifyListeners","args","_i","arguments","subscriptionManager","notify","apply","hasListeners","node","mount","instance","SVGElement","tagName","_b","layoutId","layout","visualElement","getInstance","delete","unblockTimeout_1","resizeUnblockUpdate_1","clearTimeout","window","setTimeout","globalProjectionState","hasAnimatedSinceResize","finishAnimation","registerSharedNode","animate","_c","_d","_e","_f","delta","hasLayoutChanged","hasRelativeTargetChanged","newLayout","isTreeAnimationBlocked","target","undefined","relativeTarget","layoutTransition","transition","getDefaultTransition","defaultLayoutTransition","_g","getProps","onLayoutAnimationStart","onLayoutAnimationComplete","targetChanged","targetLayout","boxEquals","hasOnlyRelativeTargetChanged","resumeFrom","currentAnimation","resumingFrom","setAnimationOrigin","animationOptions","__assign","getValueTransition","onPlay","onComplete","shouldReduceMotion","delay","type","startAnimation","isLead","onExitComplete","call","unmount","willUpdate","remove","getStack","cancelSync","preRender","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","resetRotation","shouldNotifyListeners","updateScroll","transformTemplate","prevTransformTemplateValue","updateSnapshot","didUpdate","clearMeasurements","size","mountNodeEarly","clear","resetTransformStyle","updateLayout","notifyLayoutUpdate","flushSync","update","render","clearSnapshot","removeLeadSnapshots","scheduleUpdateProjection","sync","scheduleCheckAfterUnmount","postRender","snapshot","measured","measure","removeTransform","removeElementScroll","roundBox","alwaysMeasureLayout","prevLayout","actual","layoutCorrected","createBox","projectionDelta","notifyLayoutMeasure","layoutScroll","isScrollRoot","scroll","isResetRequested","hasProjection","isDeltaZero","transformTemplateValue","transformTemplateHasChanged","hasTransform","scheduleRender","box","measureViewportBox","translateAxis","boxWithoutScroll","copyBoxInto","scroll_1","rootScroll","applyTransform","transformOnly","withTransforms","transformBox","boxWithoutTransform","hasScale","sourceBox","nodeBox","removeBoxTransforms","setTargetDelta","targetDelta","setOptions","crossfade","relativeParent","getClosestProjectingParent","relativeTargetOrigin","calcRelativePosition","targetWithTransforms","calcRelativeBox","Boolean","applyBoxDelta","attemptToResolveRelativeTarget","pendingAnimation","lead","getLead","applyTreeDeltas","createDelta","projectionDeltaWithTransform","prevTreeScaleX","prevTreeScaleY","prevProjectionTransform","projectionTransform","calcBoxDelta","buildProjectionTransform","hide","show","notifyAll","snapshotLatestValues","mixedValues","relativeLayout","isSharedLayoutAnimation","isShared","isOnlyMember","members","shouldCrossfadeOpacity","some","hasOpacityCrossfade","mixTargetDelta","latest","progress","mixAxisDelta","mixBox","animationValues","mixValues","stop","onUpdate","completeAnimation","preserveOpacity","exitAnimationComplete","applyTransformsToTarget","NodeStack","promote","initialPromotionConfig","preserveFollowOpacity","shouldPreserveFollowOpacity","stack","getPrevLead","prevLead","relegate","hasRotate","resetValues","transformAxes","key","getStaticValue","setStaticValue","syncRender","getProjectionStyles","styleProp","styles","visibility","opacity","pointerEvents","resolveMotionValue","transform","emptyStyles","valuesToRender","transformOrigin","concat","origin","opacityExit","scaleCorrectors","_h","correct","applyTo","corrected","num","resetTree","layout_1","measuredLayout","animationType","eachAxis","axis","axisSnapshot","calcLength","min","max","layoutDelta","visualDelta","parentSnapshot","parentLayout","relativeSnapshot","onBeforeLayoutMeasure","notifyBeforeLayoutMeasure","removeLeadSnapshot","output","p","translate","mix","scale","originPoint","mixAxis","from","to","duration","ease","searchNode","element","document","querySelector","roundAxis","Math","round"],"mappings":"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"}