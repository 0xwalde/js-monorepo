{"version":3,"file":"unit-conversion.mjs.js","sources":["../../../../../../../../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"sourcesContent":["import { __assign, __read } from 'tslib';\nimport { number, px } from 'style-value-types';\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from 'hey-listen';\nimport { transformProps } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) {\n    return function (_bbox, _a) {\n        var transform = _a.transform;\n        if (transform === \"none\" || !transform)\n            return 0;\n        var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n        if (matrix3d) {\n            return getPosFromMatrix(matrix3d[1], pos3);\n        }\n        else {\n            var matrix = transform.match(/^matrix\\((.+)\\)$/);\n            if (matrix) {\n                return getPosFromMatrix(matrix[1], pos2);\n            }\n            else {\n                return 0;\n            }\n        }\n    };\n};\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a, _b) {\n        var x = _a.x;\n        var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? \"0\" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? \"0\" : _d;\n        return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n    },\n    height: function (_a, _b) {\n        var y = _a.y;\n        var _c = _b.paddingTop, paddingTop = _c === void 0 ? \"0\" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? \"0\" : _d;\n        return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display;\n    var origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach(function (key) {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = __assign({}, target);\n    transitionEnd = __assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var fromType = findDimensionValueType(from);\n        var to = target[key];\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            var fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (var i = fromIndex; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var scrollY_1 = changedValueTypeKeys.indexOf(\"height\") >= 0\n            ? window.pageYOffset\n            : null;\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var _b = __read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        // Restore scroll position\n        if (scrollY_1 !== null)\n            window.scrollTo({ top: scrollY_1 });\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\nexport { BoundingBoxDimension, positionalValues, unitConversion };\n"],"names":["BoundingBoxDimension","positionalKeys","Set","isPositionalKey","key","has","setAndResetVelocity","value","to","set","isNumOrPxType","v","number","px","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","_a","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","transformProps","filter","positionalValues","width","_b","x","_c","paddingLeft","_d","paddingRight","max","min","height","y","paddingTop","paddingBottom","top","left","bottom","right","checkAndConvertChangedValueTypes","visualElement","target","origin","transitionEnd","__assign","targetPositionalKeys","Object","keys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","forEach","getValue","hasValue","toType","from","fromType","findDimensionValueType","isKeyframesTarget","numKeyframes","length","fromIndex","i","invariant","current","get","Array","isArray","map","removedTransforms","undefined","push","startsWith","syncRender","removeNonTranslationalTransform","scrollY_1","indexOf","window","pageYOffset","convertedTarget","changedKeys","originBbox","measureViewportBox","element","getInstance","elementComputedStyle","getComputedStyle","display","setStaticValue","targetBbox","convertChangedValueTypes","__read","scrollTo","unitConversion","some","hasPositionalKey"],"mappings":"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"}