{"version":3,"file":"index.mjs.js","sources":["../../../../../../../node_modules/framer-motion/dist/es/render/index.mjs"],"sourcesContent":["import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { motionValue } from '../value/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { variantPriorityOrder } from './utils/animation-state.mjs';\nimport { createLifecycles } from './utils/lifecycles.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.mjs';\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState, shouldReduceMotion = _a.shouldReduceMotion;\n        if (options === void 0) { options = {}; }\n        var isMounted = false;\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender\n         */\n        var lifecycles = createLifecycles();\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = __assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         * Render the element with the latest styles outside of the React\n         * render lifecycle\n         */\n        function render() {\n            if (!instance || !isMounted)\n                return;\n            triggerBuild();\n            renderInstance(instance, renderState, props.style, element.projection);\n        }\n        function triggerBuild() {\n            build(element, renderState, latestValues, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync.update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = __assign(__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             *\n             */\n            presenceId: presenceId, shouldReduceMotion: shouldReduceMotion, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by the projection tree, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                isMounted = true;\n                instance = element.current = newInstance;\n                if (element.projection) {\n                    element.projection.mount(newInstance);\n                }\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                values.forEach(function (value, key) { return bindToMotionValue(key, value); });\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n                element.setProps(props);\n            }, \n            /**\n             *\n             */\n            unmount: function () {\n                var _a;\n                (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n                cancelSync.update(update);\n                cancelSync.render(render);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                lifecycles.clearAllListeners();\n                instance = undefined;\n                isMounted = false;\n            }, \n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () {\n                        return closestVariantNode.variantChildren.delete(child);\n                    };\n                }\n            }, sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            }, \n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            }, \n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function () {\n                return measureViewportBox(instance, props);\n            }, \n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            }, \n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) {\n                var _a;\n                return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n            }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            }, \n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            }, \n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync.render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                if (newProps.transformTemplate || props.transformTemplate) {\n                    element.scheduleRender();\n                }\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, getTransformPagePoint: function () {\n                return props.transformPagePoint;\n            }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            } });\n        return element;\n    };\n};\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder), false);\nvar numVariantProps = variantProps.length;\n\nexport { visualElement };\n"],"names":["visualElement","_a","_b","treeType","build","getBaseTarget","makeTargetAnimatable","measureViewportBox","renderInstance","render","readValueFromInstance","removeValueFromRenderState","sortNodePosition","scrapeMotionValuesFromProps","options","parent","props","presenceId","blockInitialAnimation","visualState","shouldReduceMotion","instance","removeFromVariantTree","isMounted","latestValues","renderState","lifecycles","createLifecycles","values","Map","valueSubscriptions","prevMotionValues","baseTarget","__assign","triggerBuild","style","element","projection","update","notifyUpdate","bindToMotionValue","key","value","removeOnChange","onChange","latestValue","onUpdate","sync","removeOnRenderRequest","onRenderRequest","scheduleRender","set","initialMotionValues","undefined","isMotionValue","isControllingVariants","checkIfControllingVariants","isVariantNode","checkIfVariantNode","current","depth","children","Set","variantChildren","isVisible","manuallyAnimateOnMount","Boolean","mount","newInstance","addVariantChild","forEach","add","setProps","unmount","cancelSync","remove","delete","clearAllListeners","child","closestVariantNode","getClosestVariantNode","other","getInstance","getLayoutId","layoutId","getStaticValue","setStaticValue","getLatestValues","setVisibility","visibility","target","canMutate","addValue","hasValue","removeValue","get","has","getValue","defaultValue","motionValue","forEachValue","callback","readValue","setBaseTarget","syncRender","newProps","transformTemplate","updatePropListeners","updateMotionValuesFromProps","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getVariantContext","startAtParent","context_1","initial","context","i","numVariantProps","name_1","variantProps","prop","isVariantLabel","__spreadArray","__read","variantPriorityOrder","length"],"mappings":"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"}