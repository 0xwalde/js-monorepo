{"version":3,"file":"index.mjs.js","sources":["../../../../../../../node_modules/popmotion/dist/es/animations/index.mjs"],"sourcesContent":["import { __rest } from 'tslib';\nimport { detectAnimationFromOptions } from './utils/detect-animation-from-options.mjs';\nimport sync, { cancelSync } from 'framesync';\nimport { interpolate } from '../utils/interpolate.mjs';\nimport { hasRepeatDelayElapsed, reverseElapsed, loopElapsed } from './utils/elapsed.mjs';\n\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\nexport { animate };\n"],"names":["framesync","update","passTimestamp","delta","start","sync","stop","cancelSync","animate","_a","_b","_c","from","autoplay","driver","elapsed","repeat","repeatMax","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate","options","__rest","driverControls","latest","interpolateFromNumber","to","repeatCount","computedDuration","duration","isComplete","isForwardPlayback","animator","detectAnimationFromOptions","needsInterpolation","call","interpolate","clamp","animation","Object","assign","state","next","Math","max","value","done","hasRepeatDelayElapsed","reverseElapsed","loopElapsed","flipTarget"],"mappings":"qYAMA,MAAMA,EAAaC,IACf,MAAMC,EAAgB,EAAGC,WAAYF,EAAOE,GAC5C,MAAO,CACHC,MAAO,IAAMC,EAAKJ,OAAOC,GAAe,GACxCI,KAAM,IAAMC,EAAWN,OAAOC,GACjC,EAEL,SAASM,EAAQC,GACb,IAAIC,EAAIC,GACJC,KAAEA,EAAIC,SAAEA,GAAW,EAAIC,OAAEA,EAASd,EAASe,QAAEA,EAAU,EAAGC,OAAQC,EAAY,EAACC,WAAEA,EAAa,OAAMC,YAAEA,EAAc,EAACC,OAAEA,EAAMC,OAAEA,EAAMC,WAAEA,EAAUC,SAAEA,EAAQC,SAAEA,GAAaf,EAAIgB,EAAUC,EAAOjB,EAAI,CAAC,OAAQ,WAAY,SAAU,UAAW,SAAU,aAAc,cAAe,SAAU,SAAU,aAAc,WAAY,aACtU,IACIkB,EAGAC,EAGAC,GAPAC,GAAEA,GAAOL,EAETM,EAAc,EACdC,EAAmBP,EAAQQ,SAE3BC,GAAa,EACbC,GAAoB,EAExB,MAAMC,EAAWC,EAA2BZ,IACM,QAA7Cd,GAAMD,EAAK0B,GAAUE,0BAAuC,IAAP3B,OAAgB,EAASA,EAAG4B,KAAK7B,EAAIE,EAAMkB,MACjGD,EAAwBW,EAAY,CAAC,EAAG,KAAM,CAAC5B,EAAMkB,GAAK,CACtDW,OAAO,IAEX7B,EAAO,EACPkB,EAAK,KAET,MAAMY,EAAYN,EAASO,OAAOC,OAAOD,OAAOC,OAAO,CAAE,EAAEnB,GAAU,CAAEb,OAAMkB,QAmB7E,SAAS7B,EAAOE,GAIZ,GAHKgC,IACDhC,GAASA,GACbY,GAAWZ,GACN+B,EAAY,CACb,MAAMW,EAAQH,EAAUI,KAAKC,KAAKC,IAAI,EAAGjC,IACzCa,EAASiB,EAAMI,MACXpB,IACAD,EAASC,EAAsBD,IACnCM,EAAaC,EAAoBU,EAAMK,KAAOnC,GAAW,CAC5D,CACDS,SAAoDA,EAASI,GACzDM,IACoB,IAAhBH,IACAC,UAA+EA,EAAmBjB,IAClGgB,EAAcd,EACdkC,EAAsBpC,EAASiB,EAAkBb,EAAagB,KAjCtEJ,IACmB,YAAfb,GACAiB,EAAoBJ,EAAc,GAAM,EACxChB,EAAUqC,EAAerC,EAASiB,EAAkBb,EAAagB,KAGjEpB,EAAUsC,EAAYtC,EAASiB,EAAkBb,GAC9B,WAAfD,GACAwB,EAAUY,cAElBpB,GAAa,EACbX,GAAYA,MAGZI,EAAerB,OACfgB,GAAcA,KAwBjB,CAOD,OADAT,IAJIO,SAAgDA,IAChDO,EAAiBb,EAAOb,GACxB0B,EAAevB,SAGZ,CACHE,KAAM,KACFe,SAAgDA,IAChDM,EAAerB,MAAM,EAGjC"}