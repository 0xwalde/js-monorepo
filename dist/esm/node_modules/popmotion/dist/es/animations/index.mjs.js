import{__rest as t}from"../../../../tslib/tslib.es6.js";import{detectAnimationFromOptions as e}from"./utils/detect-animation-from-options.mjs.js";import o,{cancelSync as r}from"../../../node_modules/framesync/dist/es/index.mjs.js";import{interpolate as a}from"../utils/interpolate.mjs.js";import{hasRepeatDelayElapsed as n,reverseElapsed as s,loopElapsed as p}from"./utils/elapsed.mjs.js";const l=t=>{const e=({delta:e})=>t(e);return{start:()=>o.update(e,!0),stop:()=>r.update(e)}};function i(o){var r,i,{from:m,autoplay:d=!0,driver:u=l,elapsed:f=0,repeat:c=0,repeatType:j="loop",repeatDelay:y=0,onPlay:v,onStop:b,onComplete:x,onRepeat:g,onUpdate:T}=o,C=t(o,["from","autoplay","driver","elapsed","repeat","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate"]);let D,O,P,{to:R}=C,S=0,U=C.duration,h=!1,I=!0;const M=e(C);(null===(i=(r=M).needsInterpolation)||void 0===i?void 0:i.call(r,m,R))&&(P=a([0,100],[m,R],{clamp:!1}),m=0,R=100);const _=M(Object.assign(Object.assign({},C),{from:m,to:R}));function k(t){if(I||(t=-t),f+=t,!h){const t=_.next(Math.max(0,f));O=t.value,P&&(O=P(O)),h=I?t.done:f<=0}null==T||T(O),h&&(0===S&&(null!=U||(U=f)),S<c?n(f,U,y,I)&&(S++,"reverse"===j?(I=S%2==0,f=s(f,U,y,I)):(f=p(f,U,y),"mirror"===j&&_.flipTarget()),h=!1,g&&g()):(D.stop(),x&&x()))}return d&&(null==v||v(),D=u(k),D.start()),{stop:()=>{null==b||b(),D.stop()}}}export{i as animate};
//# sourceMappingURL=index.mjs.js.map
