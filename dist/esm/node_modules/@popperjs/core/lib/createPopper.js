import e from"./dom-utils/getCompositeRect.js";import o from"./dom-utils/getLayoutRect.js";import t from"./dom-utils/listScrollParents.js";import r from"./dom-utils/getOffsetParent.js";import n from"./dom-utils/getComputedStyle.js";import i from"./utils/orderModifiers.js";import s from"./utils/debounce.js";import a from"./utils/validateModifiers.js";import p from"./utils/uniqueBy.js";import f from"./utils/getBasePlacement.js";import d from"./utils/mergeByName.js";import{auto as c}from"./enums.js";import{isElement as m}from"./dom-utils/instanceOf.js";var u="Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.",l={placement:"bottom",modifiers:[],strategy:"absolute"};function v(){for(var e=arguments.length,o=new Array(e),t=0;t<e;t++)o[t]=arguments[t];return!o.some((function(e){return!(e&&"function"==typeof e.getBoundingClientRect)}))}function g(g){void 0===g&&(g={});var h=g,b=h.defaultModifiers,y=void 0===b?[]:b,j=h.defaultOptions,O=void 0===j?l:j;return function(g,h,b){void 0===b&&(b=O);var j={placement:"bottom",orderedModifiers:[],options:Object.assign({},l,O),modifiersData:{},elements:{reference:g,popper:h},attributes:{},styles:{}},E=[],M=!1,N={state:j,setOptions:function(e){var o="function"==typeof e?e(j.options):e;P(),j.options=Object.assign({},O,j.options,o),j.scrollParents={reference:m(g)?t(g):g.contextElement?t(g.contextElement):[],popper:t(h)};var r=i(d([].concat(y,j.options.modifiers)));if(j.orderedModifiers=r.filter((function(e){return e.enabled})),"production"!==process.env.NODE_ENV){var s=p([].concat(r,j.options.modifiers),(function(e){return e.name}));if(a(s),f(j.options.placement)===c)j.orderedModifiers.find((function(e){return"flip"===e.name}))||console.error(['Popper: "auto" placements require the "flip" modifier be',"present and enabled to work."].join(" "));var u=n(h);[u.marginTop,u.marginRight,u.marginBottom,u.marginLeft].some((function(e){return parseFloat(e)}))&&console.warn(['Popper: CSS "margin" styles cannot be used to apply padding',"between the popper and its reference element or boundary.","To replicate margin, use the `offset` modifier, as well as","the `padding` option in the `preventOverflow` and `flip`","modifiers."].join(" "))}return j.orderedModifiers.forEach((function(e){var o=e.name,t=e.options,r=void 0===t?{}:t,n=e.effect;if("function"==typeof n){var i=n({state:j,name:o,instance:N,options:r}),s=function(){};E.push(i||s)}})),N.update()},forceUpdate:function(){if(!M){var t=j.elements,n=t.reference,i=t.popper;if(v(n,i)){j.rects={reference:e(n,r(i),"fixed"===j.options.strategy),popper:o(i)},j.reset=!1,j.placement=j.options.placement,j.orderedModifiers.forEach((function(e){return j.modifiersData[e.name]=Object.assign({},e.data)}));for(var s=0,a=0;a<j.orderedModifiers.length;a++){if("production"!==process.env.NODE_ENV&&(s+=1)>100){console.error("Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.");break}if(!0!==j.reset){var p=j.orderedModifiers[a],f=p.fn,d=p.options,c=void 0===d?{}:d,m=p.name;"function"==typeof f&&(j=f({state:j,options:c,name:m,instance:N})||j)}else j.reset=!1,a=-1}}else"production"!==process.env.NODE_ENV&&console.error(u)}},update:s((function(){return new Promise((function(e){N.forceUpdate(),e(j)}))})),destroy:function(){P(),M=!0}};if(!v(g,h))return"production"!==process.env.NODE_ENV&&console.error(u),N;function P(){E.forEach((function(e){return e()})),E=[]}return N.setOptions(b).then((function(e){!M&&b.onFirstUpdate&&b.onFirstUpdate(e)})),N}}export{g as popperGenerator};
//# sourceMappingURL=createPopper.js.map
