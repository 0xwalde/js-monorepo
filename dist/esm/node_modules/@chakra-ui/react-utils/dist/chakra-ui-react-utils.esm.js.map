{"version":3,"file":"chakra-ui-react-utils.esm.js","sources":["../../../../../../node_modules/@chakra-ui/react-utils/dist/chakra-ui-react-utils.esm.js"],"sourcesContent":["import { isFunction } from '@chakra-ui/utils';\nimport * as React from 'react';\n\n/**\n * Assigns a value to a ref function or object\n *\n * @param ref the ref to assign to\n * @param value the value\n */\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (isFunction(ref)) {\n    ref(value);\n    return;\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value;\n  } catch (error) {\n    throw new Error(\"Cannot assign value '\" + value + \"' to ref '\" + ref + \"'\");\n  }\n}\n/**\n * Combine multiple React refs into a single ref function.\n * This is used mostly when you need to allow consumers forward refs to\n * internal components\n *\n * @param refs refs to assign to value to\n */\n\nfunction mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return function (node) {\n    refs.forEach(function (ref) {\n      return assignRef(ref, node);\n    });\n  };\n}\n\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\nfunction createContext(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$strict = _options.strict,\n      strict = _options$strict === void 0 ? true : _options$strict,\n      _options$errorMessage = _options.errorMessage,\n      errorMessage = _options$errorMessage === void 0 ? \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\" : _options$errorMessage,\n      name = _options.name;\n  var Context = /*#__PURE__*/React.createContext(undefined);\n  Context.displayName = name;\n\n  function useContext() {\n    var context = React.useContext(Context);\n\n    if (!context && strict) {\n      var error = new Error(errorMessage);\n      error.name = \"ContextError\";\n      Error.captureStackTrace == null ? void 0 : Error.captureStackTrace(error, useContext);\n      throw error;\n    }\n\n    return context;\n  }\n\n  return [Context.Provider, useContext, Context];\n}\n\n/**\n * Gets only the valid children of a component,\n * and ignores any nullish or falsy child.\n *\n * @param children the children\n */\n\nfunction getValidChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return /*#__PURE__*/React.isValidElement(child);\n  });\n}\n\nexport { assignRef, createContext, getValidChildren, mergeRefs };\n"],"names":["assignRef","ref","value","isFunction","current","error","Error","mergeRefs","_len","arguments","length","refs","Array","_key","node","forEach","createContext","options","_options","_options$strict","strict","_options$errorMessage","errorMessage","name","Context","React.createContext","undefined","displayName","Provider","useContext","context","React.useContext","captureStackTrace","getValidChildren","children","React.Children","toArray","filter","child","React.isValidElement"],"mappings":"uJASA,SAASA,EAAUC,EAAKC,GACtB,GAAW,MAAPD,EAEJ,GAAIE,EAAWF,GACbA,EAAIC,QAIN,IAEED,EAAIG,QAAUF,CAGf,CAFC,MAAOG,GACP,MAAM,IAAIC,MAAM,wBAA0BJ,EAAQ,aAAeD,EAAM,IACxE,CACH,CASA,SAASM,IACP,IAAK,IAAIC,EAAOC,UAAUC,OAAQC,EAAO,IAAIC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC/EF,EAAKE,GAAQJ,UAAUI,GAGzB,OAAO,SAAUC,GACfH,EAAKI,SAAQ,SAAUd,GACrB,OAAOD,EAAUC,EAAKa,EAC5B,GACA,CACA,CAOA,SAASE,EAAcC,QACL,IAAZA,IACFA,EAAU,CAAA,GAGZ,IAAIC,EAAWD,EACXE,EAAkBD,EAASE,OAC3BA,OAA6B,IAApBD,GAAoCA,EAC7CE,EAAwBH,EAASI,aACjCA,OAAyC,IAA1BD,EAAmC,6FAA+FA,EACjJE,EAAOL,EAASK,KAChBC,EAAuBC,6BAAoBC,GAgB/C,OAfAF,EAAQG,YAAcJ,EAef,CAACC,EAAQI,SAbhB,SAASC,IACP,IAAIC,EAAUC,qBAAiBP,GAE/B,IAAKM,GAAWV,EAAQ,CACtB,IAAIf,EAAQ,IAAIC,MAAMgB,GAGtB,MAFAjB,EAAMkB,KAAO,eACc,MAA3BjB,MAAM0B,mBAAqC1B,MAAM0B,kBAAkB3B,EAAOwB,GACpExB,CACP,CAED,OAAOyB,CACR,EAEqCN,EACxC,CASA,SAASS,EAAiBC,GACxB,OAAOC,EAAAA,QAAAA,SAAeC,QAAQF,GAAUG,QAAO,SAAUC,GACvD,OAAoBC,EAAAA,QAAAA,eAAqBD,EAC7C,GACA"}