{"version":3,"file":"chakra-ui-hooks.esm.js","sources":["../../../../../../node_modules/@chakra-ui/hooks/dist/chakra-ui-hooks.esm.js"],"sourcesContent":["import * as React from 'react';\nimport React__default, { useState, useMemo, useCallback, useEffect, useRef } from 'react';\nimport { u as useCallbackRef, a as useSafeLayoutEffect, b as useEventListener } from './use-animation-state-5054a9f7.esm.js';\nexport { c as useAnimationState, u as useCallbackRef, b as useEventListener, a as useSafeLayoutEffect } from './use-animation-state-5054a9f7.esm.js';\nimport copy from 'copy-to-clipboard';\nimport { runIfFn, getBox, callAllHandlers, wrapPointerEventHandler, getPointerEventName, hasFocusWithin, focus, getActiveElement, contains, isTabbable, detectBrowser, isRefObject, isActiveElement, getOwnerDocument, getAllFocusable, noop, PanSession } from '@chakra-ui/utils';\n\n/**\n * React hook to manage boolean (on - off) states\n *\n * @param initialState the initial boolean state value\n */\nfunction useBoolean(initialState) {\n  if (initialState === void 0) {\n    initialState = false;\n  }\n\n  var _useState = useState(initialState),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  var callbacks = useMemo(function () {\n    return {\n      on: function on() {\n        return setValue(true);\n      },\n      off: function off() {\n        return setValue(false);\n      },\n      toggle: function toggle() {\n        return setValue(function (prev) {\n          return !prev;\n        });\n      }\n    };\n  }, []);\n  return [value, callbacks];\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"timeout\"];\n\n/**\n * React hook to copy content to clipboard\n *\n * @param text the text or value to copy\n * @param {Number} [optionsOrTimeout=1500] optionsOrTimeout - delay (in ms) to switch back to initial state once copied.\n * @param {Object} optionsOrTimeout\n * @param {string} optionsOrTimeout.format - set the desired MIME type\n * @param {number} optionsOrTimeout.timeout - delay (in ms) to switch back to initial state once copied.\n */\nfunction useClipboard(text, optionsOrTimeout) {\n  if (optionsOrTimeout === void 0) {\n    optionsOrTimeout = {};\n  }\n\n  var _useState = useState(false),\n      hasCopied = _useState[0],\n      setHasCopied = _useState[1];\n\n  var _ref = typeof optionsOrTimeout === \"number\" ? {\n    timeout: optionsOrTimeout\n  } : optionsOrTimeout,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? 1500 : _ref$timeout,\n      copyOptions = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var onCopy = useCallback(function () {\n    var didCopy = copy(text, copyOptions);\n    setHasCopied(didCopy);\n  }, [text, copyOptions]);\n  useEffect(function () {\n    var timeoutId = null;\n\n    if (hasCopied) {\n      timeoutId = window.setTimeout(function () {\n        setHasCopied(false);\n      }, timeout);\n    }\n\n    return function () {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n      }\n    };\n  }, [timeout, hasCopied]);\n  return {\n    value: text,\n    onCopy: onCopy,\n    hasCopied: hasCopied\n  };\n}\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConst`\n * you can ensure that initializers don't execute twice or more.\n */\nfunction useConst(init) {\n  // Use useRef to store the value because it's the least expensive built-in\n  // hook that works here. We could also use `useState` but that's more\n  // expensive internally due to reducer handling which we don't need.\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = typeof init === \"function\" ? init() : init;\n  }\n\n  return ref.current;\n}\n\nfunction useControllableProp(prop, state) {\n  var isControlled = prop !== undefined;\n  var value = isControlled && typeof prop !== \"undefined\" ? prop : state;\n  return [isControlled, value];\n}\n\n/**\n * React hook for using controlling component state.\n * @param props\n */\nfunction useControllableState(props) {\n  var valueProp = props.value,\n      defaultValue = props.defaultValue,\n      onChange = props.onChange,\n      _props$shouldUpdate = props.shouldUpdate,\n      shouldUpdate = _props$shouldUpdate === void 0 ? function (prev, next) {\n    return prev !== next;\n  } : _props$shouldUpdate;\n  var onChangeProp = useCallbackRef(onChange);\n  var shouldUpdateProp = useCallbackRef(shouldUpdate);\n\n  var _React$useState = React.useState(defaultValue),\n      valueState = _React$useState[0],\n      setValue = _React$useState[1];\n\n  var isControlled = valueProp !== undefined;\n  var value = isControlled ? valueProp : valueState;\n  var updateValue = React.useCallback(function (next) {\n    var nextValue = runIfFn(next, value);\n\n    if (!shouldUpdateProp(value, nextValue)) {\n      return;\n    }\n\n    if (!isControlled) {\n      setValue(nextValue);\n    }\n\n    onChangeProp(nextValue);\n  }, [isControlled, onChangeProp, value, shouldUpdateProp]);\n  return [value, updateValue];\n}\n\n/**\n * React hook to measure a component's dimensions\n *\n * @param ref ref of the component to measure\n * @param observe if `true`, resize and scroll observers will be turned on\n */\n\nfunction useDimensions(ref, observe) {\n  var _React$useState = React.useState(null),\n      dimensions = _React$useState[0],\n      setDimensions = _React$useState[1];\n\n  var rafId = React.useRef();\n  useSafeLayoutEffect(function () {\n    if (!ref.current) return undefined;\n    var node = ref.current;\n\n    function measure() {\n      rafId.current = requestAnimationFrame(function () {\n        var boxModel = getBox(node);\n        setDimensions(boxModel);\n      });\n    }\n\n    measure();\n\n    if (observe) {\n      window.addEventListener(\"resize\", measure);\n      window.addEventListener(\"scroll\", measure);\n    }\n\n    return function () {\n      if (observe) {\n        window.removeEventListener(\"resize\", measure);\n        window.removeEventListener(\"scroll\", measure);\n      }\n\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n    };\n  }, [observe]);\n  return dimensions;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// This implementation is heavily inspired by react-aria's implementation\nfunction useId(idProp, prefix) {\n  var id = React.useId();\n  return React.useMemo(function () {\n    return idProp || [prefix, id].filter(Boolean).join(\"-\");\n  }, [idProp, prefix, id]);\n}\n/**\n * React hook to generate ids for use in compound components\n *\n * @param idProp the external id passed from the user\n * @param prefixes array of prefixes to use\n *\n * @example\n *\n * ```js\n * const [buttonId, menuId] = useIds(\"52\", \"button\", \"menu\")\n *\n * // buttonId will be `button-52`\n * // menuId will be `menu-52`\n * ```\n */\n\nfunction useIds(idProp) {\n  for (var _len = arguments.length, prefixes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    prefixes[_key - 1] = arguments[_key];\n  }\n\n  var id = useId(idProp);\n  return React.useMemo(function () {\n    return prefixes.map(function (prefix) {\n      return prefix + \"-\" + id;\n    });\n  }, [id, prefixes]);\n}\n/**\n * Used to generate an id, and after render, check if that id is rendered, so we know\n * if we can use it in places such as `aria-labelledby`.\n *\n * @param partId - The unique id for the component part\n *\n * @example\n * const { ref, id } = useOptionalPart<HTMLInputElement>(`${id}-label`)\n */\n\nfunction useOptionalPart(partId) {\n  var _React$useState = React.useState(null),\n      id = _React$useState[0],\n      setId = _React$useState[1];\n\n  var ref = React.useCallback(function (node) {\n    setId(node ? partId : null);\n  }, [partId]);\n  return {\n    ref: ref,\n    id: id,\n    isRendered: Boolean(id)\n  };\n}\n\nfunction useDisclosure(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      onCloseProp = _props.onClose,\n      onOpenProp = _props.onOpen,\n      isOpenProp = _props.isOpen,\n      idProp = _props.id;\n  var onOpenPropCallbackRef = useCallbackRef(onOpenProp);\n  var onClosePropCallbackRef = useCallbackRef(onCloseProp);\n\n  var _React$useState = React.useState(props.defaultIsOpen || false),\n      isOpenState = _React$useState[0],\n      setIsOpen = _React$useState[1];\n\n  var _useControllableProp = useControllableProp(isOpenProp, isOpenState),\n      isControlled = _useControllableProp[0],\n      isOpen = _useControllableProp[1];\n\n  var id = useId(idProp, \"disclosure\");\n  var onClose = React.useCallback(function () {\n    if (!isControlled) {\n      setIsOpen(false);\n    }\n\n    onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();\n  }, [isControlled, onClosePropCallbackRef]);\n  var onOpen = React.useCallback(function () {\n    if (!isControlled) {\n      setIsOpen(true);\n    }\n\n    onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();\n  }, [isControlled, onOpenPropCallbackRef]);\n  var onToggle = React.useCallback(function () {\n    var action = isOpen ? onClose : onOpen;\n    action();\n  }, [isOpen, onOpen, onClose]);\n  return {\n    isOpen: !!isOpen,\n    onOpen: onOpen,\n    onClose: onClose,\n    onToggle: onToggle,\n    isControlled: isControlled,\n    getButtonProps: function getButtonProps(props) {\n      if (props === void 0) {\n        props = {};\n      }\n\n      return _extends({}, props, {\n        \"aria-expanded\": isOpen,\n        \"aria-controls\": id,\n        onClick: callAllHandlers(props.onClick, onToggle)\n      });\n    },\n    getDisclosureProps: function getDisclosureProps(props) {\n      if (props === void 0) {\n        props = {};\n      }\n\n      return _extends({}, props, {\n        hidden: !isOpen,\n        id: id\n      });\n    }\n  };\n}\n\nfunction useEventListenerMap() {\n  var listeners = React.useRef(new Map());\n  var currentListeners = listeners.current;\n  var add = React.useCallback(function (el, type, listener, options) {\n    var pointerEventListener = wrapPointerEventHandler(listener, type === \"pointerdown\");\n    listeners.current.set(listener, {\n      __listener: pointerEventListener,\n      type: getPointerEventName(type),\n      el: el,\n      options: options\n    });\n    el.addEventListener(type, pointerEventListener, options);\n  }, []);\n  var remove = React.useCallback(function (el, type, listener, options) {\n    var _listeners$current$ge = listeners.current.get(listener),\n        pointerEventListener = _listeners$current$ge.__listener;\n\n    el.removeEventListener(type, pointerEventListener, options);\n    listeners.current[\"delete\"](pointerEventListener);\n  }, []);\n  React.useEffect(function () {\n    return function () {\n      currentListeners.forEach(function (value, key) {\n        remove(value.el, value.type, key, value.options);\n      });\n    };\n  }, [remove, currentListeners]);\n  return {\n    add: add,\n    remove: remove\n  };\n}\n\n/**\n * React effect hook that invokes only on update.\n * It doesn't invoke on mount\n */\n\nvar useUpdateEffect = function useUpdateEffect(effect, deps) {\n  var renderCycleRef = React.useRef(false);\n  var effectCycleRef = React.useRef(false);\n  React.useEffect(function () {\n    var isMounted = renderCycleRef.current;\n    var shouldRun = isMounted && effectCycleRef.current;\n\n    if (shouldRun) {\n      return effect();\n    }\n\n    effectCycleRef.current = true; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n  React.useEffect(function () {\n    renderCycleRef.current = true;\n    return function () {\n      renderCycleRef.current = false;\n    };\n  }, []);\n};\n\n/**\n * React hook to focus an element conditionally\n *\n * @param ref the ref of the element to focus\n * @param options focus management options\n */\nfunction useFocusEffect(ref, options) {\n  var shouldFocus = options.shouldFocus,\n      preventScroll = options.preventScroll;\n  useUpdateEffect(function () {\n    var node = ref.current;\n    if (!node || !shouldFocus) return;\n\n    if (!hasFocusWithin(node)) {\n      focus(node, {\n        preventScroll: preventScroll,\n        nextTick: true\n      });\n    }\n  }, [shouldFocus, ref, preventScroll]);\n}\n\nfunction preventReturnFocus(containerRef) {\n  var el = containerRef.current;\n  if (!el) return false;\n  var activeElement = getActiveElement(el);\n  if (!activeElement) return false;\n  if (contains(el, activeElement)) return false;\n  if (isTabbable(activeElement)) return true;\n  return false;\n}\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\n\n\nfunction useFocusOnHide(containerRef, options) {\n  var shouldFocusProp = options.shouldFocus,\n      visible = options.visible,\n      focusRef = options.focusRef;\n  var shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(function () {\n    if (!shouldFocus) return;\n\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n\n    var el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n\n    if (el) {\n      focus(el, {\n        nextTick: true\n      });\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\n\n/**\n * Credit goes to `framer-motion` of this useful utilities.\n * License can be found here: https://github.com/framer/motion\n */\n/**\n * @internal\n */\n\nfunction usePointerEvent(env, eventName, handler, options) {\n  return useEventListener(getPointerEventName(eventName), wrapPointerEventHandler(handler, eventName === \"pointerdown\"), env, options);\n}\n\n/**\n * Polyfill to get `relatedTarget` working correctly consistently\n * across all browsers.\n *\n * It ensures that elements receives focus on pointer down if\n * it's not the active element.\n *\n * @internal\n */\nfunction useFocusOnPointerDown(props) {\n  var ref = props.ref,\n      elements = props.elements,\n      enabled = props.enabled;\n  var isSafari = detectBrowser(\"Safari\");\n\n  var doc = function doc() {\n    return getOwnerDocument(ref.current);\n  };\n\n  usePointerEvent(doc, \"pointerdown\", function (event) {\n    if (!isSafari || !enabled) return;\n    var target = event.target;\n    var els = elements != null ? elements : [ref];\n    var isValidTarget = els.some(function (elementOrRef) {\n      var el = isRefObject(elementOrRef) ? elementOrRef.current : elementOrRef;\n      return contains(el, target);\n    });\n\n    if (!isActiveElement(target) && isValidTarget) {\n      event.preventDefault();\n      focus(target);\n    }\n  });\n}\n\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\nfunction useFocusOnShow(target, options) {\n  if (options === void 0) {\n    options = defaultOptions;\n  }\n\n  var _options = options,\n      focusRef = _options.focusRef,\n      preventScroll = _options.preventScroll,\n      shouldFocus = _options.shouldFocus,\n      visible = _options.visible;\n  var element = isRefObject(target) ? target.current : target;\n  var autoFocus = shouldFocus && visible;\n  var onFocus = useCallback(function () {\n    if (!element || !autoFocus) return;\n    if (contains(element, document.activeElement)) return;\n\n    if (focusRef != null && focusRef.current) {\n      focus(focusRef.current, {\n        preventScroll: preventScroll,\n        nextTick: true\n      });\n    } else {\n      var tabbableEls = getAllFocusable(element);\n\n      if (tabbableEls.length > 0) {\n        focus(tabbableEls[0], {\n          preventScroll: preventScroll,\n          nextTick: true\n        });\n      }\n    }\n  }, [autoFocus, preventScroll, element, focusRef]);\n  useUpdateEffect(function () {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(\"transitionend\", onFocus, element);\n}\n\nfunction useUnmountEffect(fn, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n\n  return React.useEffect(function () {\n    return function () {\n      return fn();\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n}\n\nfunction useForceUpdate() {\n  var unloadingRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      count = _React$useState[0],\n      setCount = _React$useState[1];\n\n  useUnmountEffect(function () {\n    unloadingRef.current = true;\n  });\n  return React.useCallback(function () {\n    if (!unloadingRef.current) {\n      setCount(count + 1);\n    }\n  }, [count]);\n}\n\n/**\n * React Hook that provides a declarative `setInterval`\n *\n * @param callback the callback to execute at interval\n * @param delay the `setInterval` delay (in ms)\n */\n\nfunction useInterval(callback, delay) {\n  var fn = useCallbackRef(callback);\n  React.useEffect(function () {\n    var intervalId = null;\n\n    var tick = function tick() {\n      return fn();\n    };\n\n    if (delay !== null) {\n      intervalId = window.setInterval(tick, delay);\n    }\n\n    return function () {\n      if (intervalId) {\n        window.clearInterval(intervalId);\n      }\n    };\n  }, [delay, fn]);\n}\n\n/**\n * React hook to persist any value between renders,\n * but keeps it up-to-date if it changes.\n *\n * @param value the value or function to persist\n */\n\nfunction useLatestRef(value) {\n  var ref = React.useRef(null);\n  ref.current = value;\n  return ref;\n}\n\n/* eslint-disable react-hooks/exhaustive-deps */\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (typeof ref === \"function\") {\n    ref(value);\n    return;\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value;\n  } catch (error) {\n    throw new Error(\"Cannot assign value '\" + value + \"' to ref '\" + ref + \"'\");\n  }\n}\n/**\n * React hook that merges react refs into a single memoized function\n *\n * @example\n * import React from \"react\";\n * import { useMergeRefs } from `@chakra-ui/hooks`;\n *\n * const Component = React.forwardRef((props, ref) => {\n *   const internalRef = React.useRef();\n *   return <div {...props} ref={useMergeRefs(internalRef, ref)} />;\n * });\n */\n\nfunction useMergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return React.useMemo(function () {\n    if (refs.every(function (ref) {\n      return ref == null;\n    })) {\n      return null;\n    }\n\n    return function (node) {\n      refs.forEach(function (ref) {\n        if (ref) assignRef(ref, node);\n      });\n    };\n  }, refs);\n}\n\nfunction useMouseDownRef(shouldListen) {\n  if (shouldListen === void 0) {\n    shouldListen = true;\n  }\n\n  var mouseDownRef = React__default.useRef();\n  useEventListener(\"mousedown\", function (event) {\n    if (shouldListen) {\n      mouseDownRef.current = event.target;\n    }\n  });\n  return mouseDownRef;\n}\n\n/**\n * Example, used in components like Dialogs and Popovers, so they can close\n * when a user clicks outside them.\n */\nfunction useOutsideClick(props) {\n  var ref = props.ref,\n      handler = props.handler,\n      _props$enabled = props.enabled,\n      enabled = _props$enabled === void 0 ? true : _props$enabled;\n  var savedHandler = useCallbackRef(handler);\n  var stateRef = useRef({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n  var state = stateRef.current;\n  useEffect(function () {\n    if (!enabled) return;\n\n    var onPointerDown = function onPointerDown(e) {\n      if (isValidEvent(e, ref)) {\n        state.isPointerDown = true;\n      }\n    };\n\n    var onMouseUp = function onMouseUp(event) {\n      if (state.ignoreEmulatedMouseEvents) {\n        state.ignoreEmulatedMouseEvents = false;\n        return;\n      }\n\n      if (state.isPointerDown && handler && isValidEvent(event, ref)) {\n        state.isPointerDown = false;\n        savedHandler(event);\n      }\n    };\n\n    var onTouchEnd = function onTouchEnd(event) {\n      state.ignoreEmulatedMouseEvents = true;\n\n      if (handler && state.isPointerDown && isValidEvent(event, ref)) {\n        state.isPointerDown = false;\n        savedHandler(event);\n      }\n    };\n\n    var doc = getOwnerDocument(ref.current);\n    doc.addEventListener(\"mousedown\", onPointerDown, true);\n    doc.addEventListener(\"mouseup\", onMouseUp, true);\n    doc.addEventListener(\"touchstart\", onPointerDown, true);\n    doc.addEventListener(\"touchend\", onTouchEnd, true);\n    return function () {\n      doc.removeEventListener(\"mousedown\", onPointerDown, true);\n      doc.removeEventListener(\"mouseup\", onMouseUp, true);\n      doc.removeEventListener(\"touchstart\", onPointerDown, true);\n      doc.removeEventListener(\"touchend\", onTouchEnd, true);\n    };\n  }, [handler, ref, savedHandler, state, enabled]);\n}\n\nfunction isValidEvent(event, ref) {\n  var _ref$current;\n\n  var target = event.target;\n  if (event.button > 0) return false; // if the event target is no longer in the document\n\n  if (target) {\n    var doc = getOwnerDocument(target);\n    if (!doc.contains(target)) return false;\n  }\n\n  return !((_ref$current = ref.current) != null && _ref$current.contains(target));\n}\n\nfunction usePanGesture(ref, props) {\n  var onPan = props.onPan,\n      onPanStart = props.onPanStart,\n      onPanEnd = props.onPanEnd,\n      onPanSessionStart = props.onPanSessionStart,\n      onPanSessionEnd = props.onPanSessionEnd,\n      threshold = props.threshold;\n  var hasPanEvents = Boolean(onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd);\n  var panSession = useRef(null);\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onSessionEnd: onPanSessionEnd,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function onEnd(event, info) {\n      panSession.current = null;\n      onPanEnd == null ? void 0 : onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    var _panSession$current;\n\n    (_panSession$current = panSession.current) == null ? void 0 : _panSession$current.updateHandlers(handlers);\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, threshold);\n  }\n\n  usePointerEvent(function () {\n    return ref.current;\n  }, \"pointerdown\", hasPanEvents ? onPointerDown : noop);\n  useUnmountEffect(function () {\n    var _panSession$current2;\n\n    (_panSession$current2 = panSession.current) == null ? void 0 : _panSession$current2.end();\n    panSession.current = null;\n  });\n}\n\nfunction usePrevious(value) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\n/**\n * Checks if the key pressed is a printable character\n * and can be used for shortcut navigation\n */\n\nfunction isPrintableCharacter(event) {\n  var key = event.key;\n  return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);\n}\n\n/**\n * React hook that provides an enhanced keydown handler,\n * that's used for key navigation within menus, select dropdowns.\n */\nfunction useShortcut(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      _props$timeout = _props.timeout,\n      timeout = _props$timeout === void 0 ? 300 : _props$timeout,\n      _props$preventDefault = _props.preventDefault,\n      preventDefault = _props$preventDefault === void 0 ? function () {\n    return true;\n  } : _props$preventDefault;\n\n  var _React$useState = React.useState([]),\n      keys = _React$useState[0],\n      setKeys = _React$useState[1];\n\n  var timeoutRef = React.useRef();\n\n  var flush = function flush() {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  };\n\n  var clearKeysAfterDelay = function clearKeysAfterDelay() {\n    flush();\n    timeoutRef.current = setTimeout(function () {\n      setKeys([]);\n      timeoutRef.current = null;\n    }, timeout);\n  };\n\n  React.useEffect(function () {\n    return flush;\n  }, []);\n\n  function onKeyDown(fn) {\n    return function (event) {\n      if (event.key === \"Backspace\") {\n        var keysCopy = [].concat(keys);\n        keysCopy.pop();\n        setKeys(keysCopy);\n        return;\n      }\n\n      if (isPrintableCharacter(event)) {\n        var _keysCopy = keys.concat(event.key);\n\n        if (preventDefault(event)) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n\n        setKeys(_keysCopy);\n        fn(_keysCopy.join(\"\"));\n        clearKeysAfterDelay();\n      }\n    };\n  }\n\n  return onKeyDown;\n}\n\n/**\n * React hook that provides a declarative `setTimeout`\n *\n * @param callback the callback to run after specified delay\n * @param delay the delay (in ms)\n */\n\nfunction useTimeout(callback, delay) {\n  var fn = useCallbackRef(callback);\n  React.useEffect(function () {\n    if (delay == null) return undefined;\n    var timeoutId = null;\n    timeoutId = window.setTimeout(function () {\n      fn();\n    }, delay);\n    return function () {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n      }\n    };\n  }, [delay, fn]);\n}\n\nfunction useWhyDidYouUpdate(name, props) {\n  var previousProps = React.useRef();\n  React.useEffect(function () {\n    if (previousProps.current) {\n      var allKeys = Object.keys(_extends({}, previousProps.current, props));\n      var changesObj = {};\n      allKeys.forEach(function (key) {\n        if (previousProps.current[key] !== props[key]) {\n          changesObj[key] = {\n            from: previousProps.current[key],\n            to: props[key]\n          };\n        }\n      });\n\n      if (Object.keys(changesObj).length) {\n        console.log(\"[why-did-you-update]\", name, changesObj);\n      }\n    }\n\n    previousProps.current = props;\n  });\n}\n\nexport { assignRef, useBoolean, useClipboard, useConst, useControllableProp, useControllableState, useDimensions, useDisclosure, useEventListenerMap, useFocusEffect, useFocusOnHide, useFocusOnPointerDown, useFocusOnShow, useForceUpdate, useId, useIds, useInterval, useLatestRef, useMergeRefs, useMouseDownRef, useOptionalPart, useOutsideClick, usePanGesture, usePointerEvent, usePrevious, useShortcut, useTimeout, useUnmountEffect, useUpdateEffect, useWhyDidYouUpdate };\n"],"names":["useBoolean","initialState","_useState","useState","exports","value","setValue","useMemo","on","off","toggle","prev","useControllableProp","prop","state","isControlled","undefined","useControllableState","props","valueProp","defaultValue","onChange","_props$shouldUpdate","shouldUpdate","next","onChangeProp","useCallbackRef","shouldUpdateProp","_React$useState","React.useState","valueState","updateValue","React.useCallback","nextValue","runIfFn","useDimensions","ref","observe","dimensions","setDimensions","rafId","React.useRef","useSafeLayoutEffect","current","node","measure","window","addEventListener","removeEventListener","cancelAnimationFrame","requestAnimationFrame","boxModel","getBox","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","useId","idProp","prefix","id","React.useId","React.useMemo","filter","Boolean","join","useIds","_len","prefixes","Array","_key","map","useDisclosure","_props","onCloseProp","onClose","onOpenProp","onOpen","isOpenProp","isOpen","onOpenPropCallbackRef","onClosePropCallbackRef","defaultIsOpen","isOpenState","setIsOpen","_useControllableProp","onToggle","getButtonProps","onClick","callAllHandlers","getDisclosureProps","hidden","useUpdateEffect","effect","deps","renderCycleRef","effectCycleRef","React.useEffect","usePointerEvent","env","eventName","handler","options","useEventListener","getPointerEventName","wrapPointerEventHandler","useFocusOnPointerDown","elements","enabled","isSafari","detectBrowser","getOwnerDocument","event","isValidTarget","some","elementOrRef","el","isRefObject","contains","isActiveElement","preventDefault","focus","useUnmountEffect","fn","useEffect","useForceUpdate","unloadingRef","count","setCount","useCallback","useInterval","callback","delay","intervalId","setInterval","clearInterval","useLatestRef","assignRef","error","Error","useMergeRefs","refs","every","forEach","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","onPanSessionEnd","threshold","hasPanEvents","panSession","useRef","handlers","onSessionStart","onSessionEnd","onStart","onMove","onEnd","info","_panSession$current","updateHandlers","PanSession","noop","_panSession$current2","end","usePrevious","useShortcut","_props$timeout","timeout","_props$preventDefault","keys","setKeys","timeoutRef","flush","clearTimeout","keysCopy","concat","pop","test","isPrintableCharacter","_keysCopy","stopPropagation","setTimeout","useTimeout","timeoutId"],"mappings":"ymBAYA,SAASA,EAAWC,QACG,IAAjBA,IACFA,GAAe,GAGjB,IAAIC,EAAYC,EAAQC,QAAAD,SAACF,GACrBI,EAAQH,EAAU,GAClBI,EAAWJ,EAAU,GAiBzB,MAAO,CAACG,EAfQE,EAAAA,QAAAA,SAAQ,WACtB,MAAO,CACLC,GAAI,WACF,OAAOF,GAAS,EACjB,EACDG,IAAK,WACH,OAAOH,GAAS,EACjB,EACDI,OAAQ,WACN,OAAOJ,GAAS,SAAUK,GACxB,OAAQA,CAClB,GACO,EAEJ,GAAE,IAEL,CA0FA,SAASC,EAAoBC,EAAMC,GACjC,IAAIC,OAAwBC,IAATH,EAEnB,MAAO,CAACE,EADIA,QAAgC,IAATF,EAAuBA,EAAOC,EAEnE,CAMA,SAASG,EAAqBC,GAC5B,IAAIC,EAAYD,EAAMb,MAClBe,EAAeF,EAAME,aACrBC,EAAWH,EAAMG,SACjBC,EAAsBJ,EAAMK,aAC5BA,OAAuC,IAAxBD,EAAiC,SAAUX,EAAMa,GAClE,OAAOb,IAASa,CACjB,EAAGF,EACAG,EAAeC,EAAeL,GAC9BM,EAAmBD,EAAeH,GAElCK,EAAkBC,EAAczB,QAAAD,SAACiB,GACjCU,EAAaF,EAAgB,GAC7BtB,EAAWsB,EAAgB,GAE3Bb,OAA6BC,IAAdG,EACfd,EAAQU,EAAeI,EAAYW,EACnCC,EAAcC,uBAAkB,SAAUR,GAC5C,IAAIS,EAAYC,EAAQV,EAAMnB,GAEzBsB,EAAiBtB,EAAO4B,KAIxBlB,GACHT,EAAS2B,GAGXR,EAAaQ,GACd,GAAE,CAAClB,EAAcU,EAAcpB,EAAOsB,IACvC,MAAO,CAACtB,EAAO0B,EACjB,CASA,SAASI,EAAcC,EAAKC,GAC1B,IAAIT,EAAkBC,EAAczB,QAAAD,SAAC,MACjCmC,EAAaV,EAAgB,GAC7BW,EAAgBX,EAAgB,GAEhCY,EAAQC,EAAAA,QAAAA,SA8BZ,OA7BAC,GAAoB,WAClB,GAAKN,EAAIO,QAAT,CACA,IAAIC,EAAOR,EAAIO,QAgBf,OAPAE,IAEIR,IACFS,OAAOC,iBAAiB,SAAUF,GAClCC,OAAOC,iBAAiB,SAAUF,IAG7B,WACDR,IACFS,OAAOE,oBAAoB,SAAUH,GACrCC,OAAOE,oBAAoB,SAAUH,IAGnCL,EAAMG,SACRM,qBAAqBT,EAAMG,QAEnC,CA1BsC,CAGlC,SAASE,IACPL,EAAMG,QAAUO,uBAAsB,WACpC,IAAIC,EAAWC,EAAOR,GACtBL,EAAcY,EACtB,GACK,CAmBL,GAAK,CAACd,IACGC,CACT,CAEA,SAASe,IAcP,OAbAA,EAAWC,OAAOC,OAASD,OAAOC,OAAOC,OAAS,SAAUC,GAC1D,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CACzC,IAAIG,EAASF,UAAUD,GAEvB,IAAK,IAAII,KAAOD,EACVP,OAAOS,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,GAG1B,CAED,OAAOL,CACX,EACSJ,EAASa,MAAMC,KAAMR,UAC9B,CAGA,SAASS,EAAMC,EAAQC,GACrB,IAAIC,EAAKC,EAAAA,QAAAA,QACT,OAAOC,EAAarE,QAAAG,SAAC,WACnB,OAAO8D,GAAU,CAACC,EAAQC,GAAIG,OAAOC,SAASC,KAAK,IACpD,GAAE,CAACP,EAAQC,EAAQC,GACtB,CAiBA,SAASM,EAAOR,GACd,IAAK,IAAIS,EAAOnB,UAAUC,OAAQmB,EAAW,IAAIC,MAAMF,EAAO,EAAIA,EAAO,EAAI,GAAIG,EAAO,EAAGA,EAAOH,EAAMG,IACtGF,EAASE,EAAO,GAAKtB,UAAUsB,GAGjC,IAAIV,EAAKH,EAAMC,GACf,OAAOI,EAAarE,QAAAG,SAAC,WACnB,OAAOwE,EAASG,KAAI,SAAUZ,GAC5B,OAAOA,EAAS,IAAMC,CAC5B,GACA,GAAK,CAACA,EAAIQ,GACV,CA0BA,SAASI,EAAcjE,QACP,IAAVA,IACFA,EAAQ,CAAA,GAGV,IAAIkE,EAASlE,EACTmE,EAAcD,EAAOE,QACrBC,EAAaH,EAAOI,OACpBC,EAAaL,EAAOM,OACpBrB,EAASe,EAAOb,GAChBoB,EAAwBjE,EAAe6D,GACvCK,EAAyBlE,EAAe2D,GAExCzD,EAAkBC,EAAczB,QAAAD,SAACe,EAAM2E,gBAAiB,GACxDC,EAAclE,EAAgB,GAC9BmE,EAAYnE,EAAgB,GAE5BoE,EAAuBpF,EAAoB6E,EAAYK,GACvD/E,EAAeiF,EAAqB,GACpCN,EAASM,EAAqB,GAE9BzB,EAAKH,EAAMC,EAAQ,cACnBiB,EAAUtD,EAAAA,QAAAA,aAAkB,WACzBjB,GACHgF,GAAU,GAGc,MAA1BH,GAA0CA,GAC9C,GAAK,CAAC7E,EAAc6E,IACdJ,EAASxD,EAAAA,QAAAA,aAAkB,WACxBjB,GACHgF,GAAU,GAGa,MAAzBJ,GAAyCA,GAC7C,GAAK,CAAC5E,EAAc4E,IACdM,EAAWjE,EAAAA,QAAAA,aAAkB,YAClB0D,EAASJ,EAAUE,IAEjC,GAAE,CAACE,EAAQF,EAAQF,IACpB,MAAO,CACLI,SAAUA,EACVF,OAAQA,EACRF,QAASA,EACTW,SAAUA,EACVlF,aAAcA,EACdmF,eAAgB,SAAwBhF,GAKtC,YAJc,IAAVA,IACFA,EAAQ,CAAA,GAGHmC,EAAS,CAAE,EAAEnC,EAAO,CACzB,gBAAiBwE,EACjB,gBAAiBnB,EACjB4B,QAASC,EAAgBlF,EAAMiF,QAASF,IAE3C,EACDI,mBAAoB,SAA4BnF,GAK9C,YAJc,IAAVA,IACFA,EAAQ,CAAA,GAGHmC,EAAS,CAAE,EAAEnC,EAAO,CACzBoF,QAASZ,EACTnB,GAAIA,GAEP,EAEL,CAwCG,IAACgC,EAAkB,SAAyBC,EAAQC,GACrD,IAAIC,EAAiBjE,kBAAa,GAC9BkE,EAAiBlE,kBAAa,GAClCmE,EAAAA,QAAAA,WAAgB,WAId,GAHgBF,EAAe/D,SACFgE,EAAehE,QAG1C,OAAO6D,IAGTG,EAAehE,SAAU,CAC1B,GAAE8D,GACHG,EAAAA,QAAAA,WAAgB,WAEd,OADAF,EAAe/D,SAAU,EAClB,WACL+D,EAAe/D,SAAU,CAC/B,CACG,GAAE,GACL,EAwEA,SAASkE,EAAgBC,EAAKC,EAAWC,EAASC,GAChD,OAAOC,EAAiBC,EAAoBJ,GAAYK,EAAwBJ,EAAuB,gBAAdD,GAA8BD,EAAKG,EAC9H,CAWA,SAASI,EAAsBnG,GAC7B,IAAIkB,EAAMlB,EAAMkB,IACZkF,EAAWpG,EAAMoG,SACjBC,EAAUrG,EAAMqG,QAChBC,EAAWC,EAAc,UAM7BZ,GAJU,WACR,OAAOa,EAAiBtF,EAAIO,QAChC,GAEuB,eAAe,SAAUgF,GAC5C,GAAKH,GAAaD,EAAlB,CACA,IAAI9D,EAASkE,EAAMlE,OAEfmE,GADkB,MAAZN,EAAmBA,EAAW,CAAClF,IACjByF,MAAK,SAAUC,GACrC,IAAIC,EAAKC,EAAYF,GAAgBA,EAAanF,QAAUmF,EAC5D,OAAOG,EAASF,EAAItE,EAC1B,KAESyE,EAAgBzE,IAAWmE,IAC9BD,EAAMQ,iBACNC,EAAM3E,GAV0B,CAYtC,GACA,CA4CA,SAAS4E,EAAiBC,EAAI7B,GAK5B,YAJa,IAATA,IACFA,EAAO,IAGFG,EAAexG,QAAAmI,WAAC,WACrB,OAAO,WACL,OAAOD,GACb,CACG,GACD7B,EACF,CAEA,SAAS+B,IACP,IAAIC,EAAehG,kBAAa,GAE5Bb,EAAkBC,EAAczB,QAAAD,SAAC,GACjCuI,EAAQ9G,EAAgB,GACxB+G,EAAW/G,EAAgB,GAK/B,OAHAyG,GAAiB,WACfI,EAAa9F,SAAU,CAC3B,IACSX,EAAiB5B,QAAAwI,aAAC,WAClBH,EAAa9F,SAChBgG,EAASD,EAAQ,EAEvB,GAAK,CAACA,GACN,CASA,SAASG,EAAYC,EAAUC,GAC7B,IAAIT,EAAK5G,EAAeoH,GACxBlC,EAAAA,QAAAA,WAAgB,WACd,IAAIoC,EAAa,KAUjB,OAJc,OAAVD,IACFC,EAAalG,OAAOmG,aALX,WACT,OAAOX,GACb,GAG4CS,IAGjC,WACDC,GACFlG,OAAOoG,cAAcF,EAE7B,CACA,GAAK,CAACD,EAAOT,GACb,CASA,SAASa,EAAa9I,GACpB,IAAI+B,EAAMK,iBAAa,MAEvB,OADAL,EAAIO,QAAUtC,EACP+B,CACT,CAGA,SAASgH,EAAUhH,EAAK/B,GACtB,GAAW,MAAP+B,EAEJ,GAAmB,mBAARA,EAKX,IAEEA,EAAIO,QAAUtC,CAGf,CAFC,MAAOgJ,GACP,MAAM,IAAIC,MAAM,wBAA0BjJ,EAAQ,aAAe+B,EAAM,IACxE,MATCA,EAAI/B,EAUR,CAcA,SAASkJ,IACP,IAAK,IAAIzE,EAAOnB,UAAUC,OAAQ4F,EAAO,IAAIxE,MAAMF,GAAOG,EAAO,EAAGA,EAAOH,EAAMG,IAC/EuE,EAAKvE,GAAQtB,UAAUsB,GAGzB,OAAOR,EAAarE,QAAAG,SAAC,WACnB,OAAIiJ,EAAKC,OAAM,SAAUrH,GACvB,OAAc,MAAPA,CACb,IACa,KAGF,SAAUQ,GACf4G,EAAKE,SAAQ,SAAUtH,GACjBA,GAAKgH,EAAUhH,EAAKQ,EAChC,GACA,CACG,GAAE4G,EACL,CAyFA,SAASG,EAAcvH,EAAKlB,GAC1B,IAAI0I,EAAQ1I,EAAM0I,MACdC,EAAa3I,EAAM2I,WACnBC,EAAW5I,EAAM4I,SACjBC,EAAoB7I,EAAM6I,kBAC1BC,EAAkB9I,EAAM8I,gBACxBC,EAAY/I,EAAM+I,UAClBC,EAAevF,QAAQiF,GAASC,GAAcC,GAAYC,GAAqBC,GAC/EG,EAAaC,iBAAO,MACpBC,EAAW,CACbC,eAAgBP,EAChBQ,aAAcP,EACdQ,QAASX,EACTY,OAAQb,EACRc,MAAO,SAAe/C,EAAOgD,GAC3BR,EAAWxH,QAAU,KACT,MAAZmH,GAA4BA,EAASnC,EAAOgD,EAC7C,GAEHpC,EAAAA,QAAAA,WAAU,WACR,IAAIqC,EAE0C,OAA7CA,EAAsBT,EAAWxH,UAA4BiI,EAAoBC,eAAeR,EACrG,IAMExD,GAAgB,WACd,OAAOzE,EAAIO,OACZ,GAAE,cAAeuH,EANlB,SAAuBvC,GACrBwC,EAAWxH,QAAU,IAAImI,EAAWnD,EAAO0C,EAAUJ,EACtD,EAIgDc,GACjD1C,GAAiB,WACf,IAAI2C,EAE2C,OAA9CA,EAAuBb,EAAWxH,UAA4BqI,EAAqBC,MACpFd,EAAWxH,QAAU,IACzB,GACA,CAEA,SAASuI,EAAY7K,GACnB,IAAI+B,EAAMgI,EAAAA,QAAAA,SAIV,OAHA7B,EAAAA,QAAAA,WAAU,WACRnG,EAAIO,QAAUtC,CAClB,GAAK,CAACA,IACG+B,EAAIO,OACb,CAgBA,SAASwI,EAAYjK,QACL,IAAVA,IACFA,EAAQ,CAAA,GAGV,IAAIkE,EAASlE,EACTkK,EAAiBhG,EAAOiG,QACxBA,OAA6B,IAAnBD,EAA4B,IAAMA,EAC5CE,EAAwBlG,EAAO+C,eAC/BA,OAA2C,IAA1BmD,EAAmC,WACtD,OAAO,CACR,EAAGA,EAEA1J,EAAkBC,EAAczB,QAAAD,SAAC,IACjCoL,EAAO3J,EAAgB,GACvB4J,EAAU5J,EAAgB,GAE1B6J,EAAahJ,EAAAA,QAAAA,SAEbiJ,EAAQ,WACND,EAAW9I,UACbgJ,aAAaF,EAAW9I,SACxB8I,EAAW9I,QAAU,KAE3B,EAsCE,OA5BAiE,EAAAA,QAAAA,WAAgB,WACd,OAAO8E,CACR,GAAE,IAEH,SAAmBpD,GACjB,OAAO,SAAUX,GACf,GAAkB,cAAdA,EAAM7D,IAAqB,CAC7B,IAAI8H,EAAW,GAAGC,OAAON,GAGzB,OAFAK,EAASE,WACTN,EAAQI,EAET,CAED,GAxDN,SAA8BjE,GAC5B,IAAI7D,EAAM6D,EAAM7D,IAChB,OAAsB,IAAfA,EAAIF,QAAgBE,EAAIF,OAAS,GAAK,eAAemI,KAAKjI,EACnE,CAqDUkI,CAAqBrE,GAAQ,CAC/B,IAAIsE,EAAYV,EAAKM,OAAOlE,EAAM7D,KAE9BqE,EAAeR,KACjBA,EAAMQ,iBACNR,EAAMuE,mBAGRV,EAAQS,GACR3D,EAAG2D,EAAUrH,KAAK,KA7BtB8G,IACAD,EAAW9I,QAAUwJ,YAAW,WAC9BX,EAAQ,IACRC,EAAW9I,QAAU,IACtB,GAAE0I,EA2BA,CACP,CACG,CAGH,CASA,SAASe,EAAWtD,EAAUC,GAC5B,IAAIT,EAAK5G,EAAeoH,GACxBlC,EAAAA,QAAAA,WAAgB,WACd,GAAa,MAATmC,EAAJ,CACA,IAAIsD,EAIJ,OAHAA,EAAYvJ,OAAOqJ,YAAW,WAC5B7D,GACD,GAAES,GACI,WACDsD,GACFvJ,OAAO6I,aAAaU,EAE5B,CATuC,CAUvC,GAAK,CAACtD,EAAOT,GACb"}